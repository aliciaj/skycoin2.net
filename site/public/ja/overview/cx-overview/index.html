<!DOCTYPE html>
<html lang="en-us">
  
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CXの概要 | Skycoin Blog</title>
  <link rel="stylesheet" href="../../../css/main.css" />
  
    <meta property="og:title" content="CXの概要">
    
    <meta property="og:type" content="article">
    <meta property="article:published_time" content="2017-09-06">
    
    <meta property="og:description" content="">
    <meta property="og:url" content="https://www.skycoin.net/ja/overview/cx-overview/">
    <meta property="og:site_name" content="Skycoin Blog">
    
    
    <meta property="og:tags" content="CX">
    
    
  
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105234182-1', 'auto');
    ga('send', 'pageview');
    </script>
  
</head>

<body>
<header class="site-header color-light">
	<div class="logo-container">
		<a href="../../../" class="logo"><span>Skycoin</span></a>
	</div>
	<nav class="nav">
		<ul>
			
				
				<li class="has-dropdown">
					<span class="nav-link">Technology</span>
					<ul>
						
						<li>
							<a class="dropdown-item nav-item-skywire" href="../../../ja/skywire">Skywire</a>
						</li>
						
						<li>
							<a class="dropdown-item nav-item-skycoin" href="../../../ja/skycoin">Skycoin</a>
						</li>
						
						<li>
							<a class="dropdown-item nav-item-skyledger" href="../../../ja/skyledger">Skyledger</a>
						</li>
						
					</ul>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-whitepapers" href="../../../ja/whitepapers/">Whitepapers</a>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-roadmap" href="../../../ja/roadmap/">Roadmap</a>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-downloads" href="../../../ja/downloads/">Downloads</a>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-blog" href="../../../ja/blog/">Blog</a>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-markets" href="../../../ja/markets/">Buy Skycoin</a>
				</li>
				
			
		</ul>
	</nav>	
</header>

<section id="main">
	<div class="hero ">
	    <h1 id="title">CXの概要</h1>
    </div>

    <article id="content">
        

<!-- MarkdownTOC autolink="true" bracket="round" depth="2" -->

<ul>
<li><a href="#%e5%ba%8f%e6%96%87">序文</a></li>
<li><a href="#%e3%83%97%e3%83%ad%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e3%81%ae%e3%83%aa%e3%83%9d%e3%82%b8%e3%83%88%e3%83%aa">プロジェクトのリポジトリ</a></li>
<li><a href="#%e6%a7%8b%e6%96%87">構文</a></li>
<li><a href="#%e3%82%a2%e3%83%95%e3%82%a9%e3%83%bc%e3%83%80%e3%83%b3%e3%82%b9">アフォーダンス</a>

<ul>
<li><a href="#%e5%bc%95%e6%95%b0%e3%81%ae%e5%80%8b%e6%95%b0%e3%81%ae%e5%88%b6%e7%b4%84">引数の個数の制約</a></li>
<li><a href="#%e5%9e%8b%e3%81%ae%e5%88%b6%e7%b4%84">型の制約</a></li>
<li><a href="#%e5%ad%98%e5%9c%a8%e3%81%ae%e5%88%b6%e7%b4%84">存在の制約</a></li>
<li><a href="#%e8%ad%98%e5%88%a5%e5%ad%90%e3%81%ae%e5%88%b6%e7%b4%84">識別子の制約</a></li>
<li><a href="#%e5%a2%83%e7%95%8c%e3%81%ae%e5%88%b6%e7%b4%84">境界の制約</a></li>
<li><a href="#%e3%83%a6%e3%83%bc%e3%82%b6%e3%83%bc%e5%ae%9a%e7%be%a9%e3%81%ae%e5%88%b6%e7%b4%84">ユーザー定義の制約</a></li>
</ul></li>
<li><a href="#%e5%bc%b7%e3%81%84%e5%9e%8b%e4%bb%98%e3%81%91%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0">強い型付けシステム</a></li>
<li><a href="#%e3%82%b3%e3%83%b3%e3%83%91%e3%82%a4%e3%83%ab%e3%81%a8%e9%80%90%e6%ac%a1%e5%ae%9f%e8%a1%8c">コンパイルと逐次実行</a>

<ul>
<li><a href="#read-eval-print-loop">Read-Eval-Print Loop</a></li>
<li><a href="#%e3%83%a1%e3%82%bf%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%9f%e3%83%b3%e3%82%b0%e3%82%b3%e3%83%9e%e3%83%b3%e3%83%89">メタプログラミングコマンド</a></li>
<li><a href="#%e3%82%b9%e3%83%86%e3%83%83%e3%83%94%e3%83%b3%e3%82%b0">ステッピング</a></li>
<li><a href="#%e5%af%be%e8%a9%b1%e7%9a%84%e3%81%aa%e3%83%87%e3%83%90%e3%83%83%e3%82%b0">対話的なデバッグ</a></li>
</ul></li>
<li><a href="#%e7%b5%b1%e5%90%88%e3%81%95%e3%82%8c%e3%81%9f%e9%80%b2%e5%8c%96%e7%9a%84%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0">統合された進化的アルゴリズム</a></li>
<li><a href="#%e3%82%b7%e3%83%aa%e3%82%a2%e3%83%a9%e3%82%a4%e3%82%bc%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3">シリアライゼーション</a></li>
</ul>

<!-- /MarkdownTOC -->

<h1 id="序文">序文</h1>

<p>CXとは、アフォーダンスの概念に基づいた新しいプログラミングパラダイムを採用して設計された、仕様とプログラミング言語の両方を指します。
アフォーダンスは、何ができて、何ができないのかをプログラムが知ることを可能にします。
たとえば、関数にどのような引数を送ることができるかをプログラムに照会することができ、プログラムは可能なアクションのリストを返します。
リストからどのようなアクションが適切であるかを決定した後、選択肢の1つを選び、そのアクションをプログラムが実行します。
CXのアフォーダンスシステムの重要な要素は、遺伝的プログラミングアルゴリズムが構築されると、実行時にプログラムの構造を最適化するために使用できるネイティブ関数として提供される事です。</p>

<p>CXの仕様では、プログラマはコンパイラとインタプリタの両方にアクセス可能でなければならないとされています。
インタプリタは、プログラマが対話的に要素をプログラムに追加したり削除したりできるREPL(Read-eval-print loop)を通じてアクセスできます。
プログラムが完成すると、そのパフォーマンスを向上させるためにコンパイルすることができます。</p>

<p>CXの型システムは非常に厳格です。
唯一の &ldquo;暗黙の型変換&rdquo;は、パーサーが整数、浮動小数点数、ブール値、文字列、または配列を判別するときに発生します。
たとえば、関数が64ビット整数を必要とする場合、明示的に必要な型に変換するためには、キャスト関数を使用する必要があります。</p>

<p>最後に、CXプログラムをバイト配列に完全にシリアライズして、実行状態と構造を維持することができます。
このシリアライズされたバージョンのプログラムは、後でデシリアライズして、CXインタープリタ/コンパイラを持つ任意のデバイスでその実行を再開することができます。</p>

<p>以下のセクションでは、上で説明したCXの機能について詳しく説明します。</p>

<h1 id="プロジェクトのリポジトリ">プロジェクトのリポジトリ</h1>

<p>プロジェクトのソースコードは、Githubリポジトリ<a href="https://github.com/skycoin/cx">https://github.com/skycoin/cx</a> からダウンロードできます。
リポジトリには、仕様ファイル、ドキュメント、サンプル、およびソースコードが含まれています。</p>

<h1 id="構文">構文</h1>

<p>はじめに述べたように、CXは仕様とプログラミング言語の両方を指します。
CX仕様は構文を規定するのではなく、むしろCXとみなすためにCX言語が実装しなければならない構造とプロセスを規定しています。
結果として、2つのCX言語を実装することができ、1つはLispのような構文で、もう1つはCのような構文です。
この基礎となる言語は、CX Base、すなわち「基本言語」と呼ばれています。
このドキュメントでは、実装は仕様の機能を示すために使用されていますが、その目的は学術ツールとしての機能だけでなく、一般的な目的に使用できる完全で堅牢な言語となることです。</p>

<p>このドキュメントで使用されているCXは、Goの構文にできるだけ似た構文を持つことを目標としています。</p>

<h1 id="アフォーダンス">アフォーダンス</h1>

<p>プログラマは、関数が受け取るパラメータの数、戻すパラメータの数、目的の機能を得るために必要な記述、文関数にパラメータとして送る必要がある引数など、プログラムを構築する際に非常に多くの決定をする必要があります。
CXのアフォーダンスシステムでは、要素に適用できる可能なアクションのリストを取得するための照会を受けることができます。
この文脈では、要素の例は、関数、構造体、モジュール、および式です。</p>

<p>プログラムの背後にある、ロジックと目的が何であるべきかを指示する一連のルールとファクトを持たずに、少なくともプログラムが意味論的に正しいことを保証する基本的な制約をいくつか決めることができます。
アフォーダンスシステムは、第1のフィルタリング層として、以下で説明する制約を提供します。</p>

<h3 id="引数の個数の制約">引数の個数の制約</h3>

<p>CXの式は複数の値を返すことができます。
これは、式の出力引数を受け取る変数の数が、式の演算子で定義された出力の数と一致する必要があるため、アフォーダンスシステムの仕事となります。</p>

<pre><code>out1, out2, ..., outN := op(inp1, inp2, ..., inpM)
</code></pre>

<p>上記の例が正しい場合、*op*は*N*個の引数を出力する必要があります。
*op*の定義がアフォーダンスシステム自体またはユーザーによって将来変更され得ることを考慮すると、この問題はさらに複雑になり得ます。
*op*の定義が変更されるとすぐに、*op*の出力引数を受け取る変数の数が不一致になるため、新しいアフォーダンスが*op*を演算子として使っているどんな式にも適用されます。</p>

<p>前のロジックはまた、受信変数の数が式の演算子の出力パラメータの数と一致する場合、新しい受信変数を追加する動作がもはや実行できないことを意味します。</p>

<p>引数の個数の制約は、式の入力引数にも適用されます。
つまり、関数呼び出しのすべての入力引数がすでに定義されている場合、アフォーダンスシステムは、別の引数を可能なアクションとして追加する必要がありません。
同様に、式が必要な数よりも少ない引数を持つ演算子を呼び出そうとしている場合、アフォーダンスシステムは照会を受けた時に、新しい引数を関数呼び出しに追加できることをプログラマに伝える必要があります。</p>

<p><strong>例：</strong></p>

<p><em>注：文字列の連結はまだ実装されていません。
また、print関数は、表示される文字列の最後に常に改行を追加します。
このドキュメントで紹介するCX実装の将来のバージョンでは、これらの問題が解決されます。</em></p>

<pre><code>var age i32 = 18
var steps i32 = 23

func advance (direction str, numberSteps i32) () {
    printStr(&quot;Advancing:&quot;)
    printStr(direction)
    printStr(&quot;Number of steps:&quot;)
    printI32(numberSteps)
}

func main () () {
    advance(&quot;North&quot;)
}
</code></pre>

<p>上記の例では、*main*関数内の*advance*の呼び出しで引数が１つ不足しています。
アフォーダンスシステムに照会すると、システムは次のような行動を取ります。</p>

<pre><code>...
(k)       AddArgument advance age
(k+1)     AddArgument advance steps
...
</code></pre>

<p>ここでkは任意のインデックスを表します。
アフォーダンスシステムは、2つのアクションが実行可能で、それらは*advance*関数に別の引数を追加することをプログラマに告げており、グローバル変数の*age*と*steps*は引数となり得る選択肢です。</p>

<p>アフォーダンスは常に列挙されるべきであり、アフォーダンスシステムへの照会においてそれらの順序が一定であるべきことは重要です。
その理由は、プログラマが照会の結果を調べた後に、どのアフォーダンスを適用するのかをシステムに示す必要があるためです。</p>

<h3 id="型の制約">型の制約</h3>

<p>プログラミング言語における共通の挙動は、プログラマーが予期しない型の引数を関数呼び出しに送ることを制限する型システムを持つことです。
たとえ弱く型付けされたプログラミング言語であっても、次の演算<code>true / &quot;hello world&quot;</code>はエラーを発生させるはずです(もちろん、<a href="https://ja.wikipedia.org/wiki/%E9%9B%A3%E8%A7%A3%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E">難解プログラミング言語</a>の場合を除いて).
CXは非常に<a href="#%e5%bc%b7%e3%81%84%e5%9e%8b%e4%bb%98%e3%81%91%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0">強い型付けシステム</a>に従っており 、予想される型ではない引数は、アフォーダンスのアクションの候補と見なすべきではありません（回避策は、アフォーダンスとして表示される前にこれらの引数をキャスト関数で囲みます）。</p>

<p>すでに存在する変数に新しい値を割り当てる場合は、型の制約も考慮する必要があります。
CXでは、特定の型の宣言された変数は、全てのライフタイム中で（その型がメタプログラミングのコマンド/関数を使用して削除され、新たに作成されない限り）、その型のままでなければなりません。
したがって、32ビット整数を保持すると宣言された変数は、例えば64ビット浮動小数点出力引数を受け取る候補とはみなされません。</p>

<h3 id="存在の制約">存在の制約</h3>

<p>このタイプの制約は一見すると些細なことに思えるかもしれません。&rdquo;要素が存在しない場合、その要素を含むアフォーダンスは存在してはならない&rdquo;
にもかかわらず、関数の名前が変更され、プログラム中の式の演算子としてすでに使用されている状況を考えれば、この制約は困難になります。
プログラムがソースコード形式であれば、この問題は単純な「検索と置換」プロセスになりますが、実行時には&rdquo;演算子にバインドされた識別子を変更するアフォーダンス&rdquo;として、アフォーダンスシステムが非常に便利になります。</p>

<p>要素の名前を変更しない場合でも、要素が存在するかどうかを判定することは簡単ではありません。
アフォーダンスで使用される要素は、コールスタックの現在のスコープ、グローバルスコープ、および他のモジュールのグローバルスコープで検索する必要があります。</p>

<h3 id="識別子の制約">識別子の制約</h3>

<p>新しい名前付き要素を追加することは、一般的に、アフォーダンスの候補アクションです。
そのようなタイプのアフォーダンスを適用しようとするときに生じる制約は、再定義を避けるため新しい要素に一意の識別子を割り当てることです。
アフォーダンスシステムは、要素のスコープ内に固有の識別子を生成するか、またはプログラマに適切な識別子を提供するように要求することができます。</p>

<h3 id="境界の制約">境界の制約</h3>

<p>CXは、配列内の要素にアクセスし変更するためのネイティブ関数を提供します。
配列読み出しと配列書き込みの例は次のとおりです。</p>

<pre><code>readI32([]i32{0, 10, 20, 30}, 3)
writeF32([]f32{0.0, 10.10, 20.20}, 1, 5.5)
</code></pre>

<p>最初の式では、4つの32ビット整数の配列がインデックス3でアクセスされ、配列の最後の要素が返されます。
2番目の式では、3つの32ビット浮動小数点数の配列の2番目の要素が5.5に変更されています。
これらの配列のいずれかが、負のインデックスまたは配列の長さを超えるインデックスを使用してアクセスされた場合、「境界外」エラーが発生します。</p>

<p>型の制約のみに従うことによって、アフォーダンスシステムは、任意の32ビット整数引数を任意の配列にアクセスするためのインデックスとして使用できることをプログラマに通知します。
これらのプログラムはコンパイルされますが、プログラマが特別な注意を払わなければ、境界外のエラーが発生する可能性は非常に高いです。</p>

<p>アフォーダンスシステムは、以下の基準に従ってアフォーダンスをフィルタリングする必要があります。
負の32ビット整数を破棄し、配列読み出し関数または書き込み関数に送信される配列の長さを超える32ビット整数を破棄します。</p>

<h3 id="ユーザー定義の制約">ユーザー定義の制約</h3>

<p><em>注：ユーザー定義の制約システムはまだ実験段階です。</em></p>

<p>上記の基本的な制約は、プログラムがランタイムエラーに遭遇しないことを少なくとも保証するべきです。
これらの制約は、CXの固有の<a href="#%e7%b5%b1%e5%90%88%e3%81%95%e3%82%8c%e3%81%9f%e9%80%b2%e5%8c%96%e7%9a%84%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0">進化的アルゴリズム</a>などの興味深いシステムを構築するのに十分なものでなければなりません。
それにもかかわらず、場合によってはより堅牢なシステムが必要とされます。
この目的のために、節、クエリ、およびオブジェクトは、モジュールの環境を記述するために使用されます。
これらの要素は、統合されたPrologインタプリタと、CXネイティブ関数*setClauses*、*setQuery*、および*addObject*を使用して定義されます。</p>

<p>この制約システムの最も一般的な説明は、追加された各オブジェクトに対して、定義されたPrologクエリを使用して照会される一連のProlog句（ファクトとルール）をプログラマが定義することです。
この説明は、初めてこれを読んだ人にとっては、ほとんど意味不明でしょう。
次の例は、概念とプロセスをもう少し明確にしてくれるはずです。</p>

<pre><code>setClauses(&quot;move(robot, north, X, R) :- X = northWall, R = false.&quot;)

setQuery(&quot;move(robot, %s, %s, R).&quot;)
</code></pre>

<p>この例では、1つのルールしか定義されていません。
このルールは、「ロボットが北に移動したい場合はXが何であるかを尋ねる。もしXがnorthWallだった場合は移動できない」と概ね解釈できます。
クエリはアクション*move*のクエリとして機能する書式文字列です。
それは方向とオブジェクトという2つの引数を受け取る要素*robot*のためのものです。</p>

<p>オブジェクトは、*addObject*関数を使用して定義できます。</p>

<pre><code>addObject(&quot;southWall&quot;)
addObject(&quot;northWall&quot;)
</code></pre>

<p>制約システムは、モジュールに存在するオブジェクトのそれぞれについてシステムに照会します。
この例では、システムはまず「move（robot、north、southWall）」というクエリを実行し、システムは「nil」と応答します。
つまり、このような状況を処理するためのルールは定義されていません。
そしてデフォルトのアクションはアフォーダンスを破棄しません。
2番目のクエリは &ldquo;move（robot、north、northWall）&rdquo;になり、システムは &ldquo;false&rdquo;と応答します。
この場合、アフォーダンスはテストに合格しておらず、破棄されます。</p>

<p>上記の例は、これらのルールが条件を使用してアフォーダンスを否定する方法を示しています。
しかし、前のルールによって否定された後でも、ルールはアフォーダンスを受け入れるために使用できます。</p>

<pre><code>setClauses(&quot;move(robot, north, X, R) :- X = northWall, R = false.
    move(robot, north, X, R) :- X = northWormhole, R = true.&quot;)

setQuery(&quot;move(robot, %s, %s, R).&quot;)
</code></pre>

<p>上記のコードで追加されたルールは、ワームホールが存在する場合、北に向かうロボットの動きを受け入れるようにシステムに指示します。
オブジェクト配列が前に定義した通りに残っていれば、移動アフォーダンスは破棄されますが、 <code>addObject(&quot;northWormhole&quot;)</code> が評価された場合は、「northWormhole」が追加され、ロボットはワームホールを使用して壁を通過することができます。</p>

<h1 id="強い型付けシステム">強い型付けシステム</h1>

<p>はじめに述べたように、CXには暗黙のキャストはありません。
このため、各プリミティブ型の複数のバージョンがコアモジュールで定義されています。
たとえば、addI32、addI64、addF32、およびaddF64の4つのネイティブ関数が存在します。</p>

<p>パーサーは、ソースコード内で見つかったデータにデフォルトの型を付与します。
整数が読み取られた場合、デフォルトの型は*i32*または32ビット整数です。
浮動小数点が読み取られた場合、デフォルトの型は*f32*または32ビットfloatです。
パーサーが読み取る他のデータにはあいまいさはありません。
*true*と<em>false</em> は常にブーリアンです。
ダブルクォーテーションで囲まれた一連の文字は常に文字列です。
配列は <code>[]i64{1, 2, 3}</code>のように要素のリストの前にその型を示す必要があります。</p>

<p>プログラマがある型の値を別の型に明示的にキャストする必要がある場合、コアモジュールはプリミティブ型を扱うためにいくつかのキャスト関数を提供します。
たとえば<code>byteAToStr</code>はバイト配列を文字列にキャストし、<code>i32ToF32</code>は32ビットの整数を32ビットのfloatにキャストします。</p>

<h1 id="コンパイルと逐次実行">コンパイルと逐次実行</h1>

<p>CX仕様では、開発者にインタプリタとコンパイラの両方を提供するためにCX言語が適用されています。
逐次実行されるプログラムは、コンパイルされたプログラムよりもはるかに遅いですが、より柔軟なプログラムが可能になります。
この柔軟性は、メタプログラミング機能、および実行時にプログラムの構造を変更するアフォーダンスによってもたらされます。</p>

<p>コンパイルされたプログラムは、多くの最適化処理がその堅牢性を利用するため、逐次実行プログラムよりも堅牢な構造を必要とします。
結果として、アフォーダンスシステムおよびプログラム構造上で動作する機能は、コンパイルされたプログラムではその機能が制限されます。</p>

<p>パフォーマンスが最大の関心事である場合はコンパイラを使用するべきですが、プログラマがCX機能によって提供されるすべての柔軟性を必要とする場合は、プログラムを逐次実行プログラムのままにしておく必要があります。
以下のサブセクションでは、これらの機能の一部をチュートリアルとして提供するのではなく、単なる紹介として提示します。</p>

<h3 id="read-eval-print-loop">Read-Eval-Print Loop</h3>

<p>Read-Eval-Print Loop　(REPL) は、プログラマが新しいプログラム要素を入力し評価することができる対話的なツールです。
 新しいREPLセッションを開始すると、次のメッセージがコンソールに出力されます。</p>

<pre><code>CX REPL
More information about CX is available at https://github.com/skycoin/cx

*
</code></pre>

<p>&ldquo;*&ldquo;は、REPLが新しいコード行を受け取る準備ができていることをプログラマーに伝えます。
REPLはセミコロンと改行文字が出現するまでユーザーからの入力を読み続けます。</p>

<p>REPLに最初にロードされたプログラムがない場合、CXは空のプログラムから開始します。
これは、メタプログラミングコマンド<code>:dProgram true;</code>が入力として与えられている場合に見ることができます。</p>

<pre><code>* :dProgram true;
Program

*
</code></pre>

<p>REPLは &ldquo;Program&rdquo;という単語を続けて表示し、その後に空の行を表示します。
最初のステップとして、新しいモジュールと関数を宣言することができます。:</p>

<p>最初のステップとして、新しい<em>main</em> モジュールと新しい*main*関数を宣言する必要があります。</p>

<pre><code>* package main;
Program
0.- Module: main

* func main () () {};
Program
0.- Module: main
	Functions
		0.- Function: main () ()

*
</code></pre>

<p>見て分かるように、新しい要素がプログラムに追加されるたびにプログラム構造が表示されています。</p>

<h3 id="メタプログラミングコマンド">メタプログラミングコマンド</h3>

<p>上記のサブセクションで<code>:dProgram</code>が使用されました。
コロン（:)で始まる文は、「メタプログラミングコマンド」と呼ばれる命令カテゴリの一部です。</p>

<p>REPLの要素を宣言すると、CXのプログラム構造に追加されます。
しかし、他の多くのプログラミング言語と同様に、これらの宣言は追加されただけで、たいていは再定義されます。</p>

<p>しかし、REPLを提供する他の多くのプログラミング言語のように、プログラマはプログラムに新しい要素を追加することに制限があり、多くの場合、要素を再定義しています。
メタプログラミングコマンドを使用すると、プログラマーは、プログラムの構造がどのように変更されているか、より詳細に制御できます。</p>

<p><code>:dProgram</code>、<code>:dState</code>、<code>:dStack</code>はそれぞれ、ユーザーにプログラムの構造、現在の呼び出しの状態、および完全なコールスタックを表示することによって、デバッグ目的にのみ使用されます。
<code>:step</code> は、インタプリタに実行の前進または後退を指示します。
<code>:package</code>、<code>:func</code>、<code>:struct</code>は、*selectors*として知られており、プログラムのスコープを変更するために使用されます。
<code>:rem</code>は、プログラムの構造から要素を選択的に削除するために使用できる*removers*へのアクセスをプログラマに提供します。
<code>:aff</code>は、CXのアフォーダンスシステムにアクセスするために使用されます。このメタプログラミングコマンドは、プログラムのさまざまな要素のためのアフォーダンスを照会および適用するために使用されます。
<code>:clauses</code>は<a href="#%e3%83%a6%e3%83%bc%e3%82%b6%e3%83%bc%e5%ae%9a%e7%be%a9%e3%81%ae%e5%88%b6%e7%b4%84">ユーザー定義制約システム</a>で使われるモジュールの節を設定するために使用されます。
<code>:object</code>と<code>:objects</code>は、それぞれのオブジェクトを追加し、表示するために使用されます。
<code>:query</code>は、モジュールのクエリを設定するために使用され、<code>:dQuery</code>はユーザー定義の制約をデバッグするヘルパーです。</p>

<h3 id="ステッピング">ステッピング</h3>

<p>REPLモードで起動されたプログラムは、ソースファイルで定義されたプログラム構造で初期化することができます。
たとえば、次のコマンドは</p>

<pre><code>$ ./cx --load examples/looping.cx

</code></pre>

<p>サンプルディレクトリから<code>looping.cx</code>を読み込みます(全てのサンプルのリストは<a href="https://github.com/skycoin/cx">プロジェクトリポジトリ</a>にあります).
プログラムはロードされても、まだ実行されていません。
REPLでは、プログラムを実行するためにメタプログラミングコマンド<code>:step</code>を使用する必要があります。
最後までプログラムを実行するには、<code>:step 0;</code>を使用する必要があります。
しかし、<code>:step</code> は他の整数を引数（負の整数さえ）として取ることができるため興味深いです。
例えば</p>

<pre><code>CX REPL
More information about CX is available at https://github.com/skycoin/cx

* :dStack false;

* :step 5;
0

* :step 5;
1

* :step 5;
2

*
</code></pre>

<p>*examples/looping.cx*のプログラムは一度に5つのステップを実行しています。
プログラムが*while*条件を再評価し、カウンタを出力し、カウンタに1を加えるために5つのステップが必要であることがわかります。</p>

<p>同様に、REPLに<code>:step -5</code>が指示されている場合は、「時間を戻す」ことになります。</p>

<pre><code>...

* :step 5;
2

* :step -5;

* :step 5;
2

*
</code></pre>

<p>CXに5ステップを進めるように指示した後、2が再びコンソールに表示されます。
カウンタには異なる値が割り当てられているわけでは無いので、注意する必要があります。
起こっていることは、コールスタックが以前の状態に戻っているということです。</p>

<h3 id="対話的なデバッグ">対話的なデバッグ</h3>

<p>エラーが検出されると、CXプログラムはREPLモードに入ります。
この動作により、プログラムの実行を再開しようとする前に、プログラムをデバッグする機会がプログラマに与えられます。</p>

<p>以下の例では、0による除算が発生し、REPLはエラーについてプログラマに警告し、コールスタックの最後の呼び出しをダンプし、REPLはその実行を継続します。</p>

<pre><code>CX REPL
More information about CX is available at https://github.com/skycoin/cx

* package main;

* func main () () {};

* :func main;
main
:func main {...
	* foo := divI32(5, 3);
main
:func main {...
	* bar := divI32(10, 0);
main
:func main {...
	* :step 0;
fn:main ln:0, 	locals:
&gt;&gt; 1
fn:main ln:1, 	locals: foo: 1

Call's State:
foo:		1

divI32() Arguments:
0: 10
1: 0

0: divI32: Division by 0
main
:func main {...
	*
</code></pre>

<p>同様に、プログラムがCXインタプリタへの入力として与えられ、REPLを呼び出さずにエラーが発生した場合、プログラマまたはシステム管理者がプログラムをデバッグするためにREPLが呼び出されます。</p>

<pre><code>$ ./cx examples/program-halt.cx
1

Call's State:
nonAssign_0:		1
nonAssign_1:		1

divI32() Arguments:
0: 5
1: 0

5: divI32: Division by 0
CX REPL
More information about CX is available at https://github.com/skycoin/cx

*
</code></pre>

<h1 id="統合された進化的アルゴリズム">統合された進化的アルゴリズム</h1>

<p>CXのアフォーダンスシステムとメタプログラミング機能は、管理された方法でプログラムの構造を変更する柔軟性を実現します。
しかしながら、アフォーダンスは、適用されるアフォーダンスのインデックスを選択する機能を持つことによって、自動化することができます。</p>

<p><code>evolve</code>はランダムなアフォーダンスを使用してユーザー定義関数を構築するネイティブ関数です。
対話的なプロセスがテストのために使用されます。</p>

<p><code>evolve</code> は進化的計算の原則に従います。
特に、<code>evolve</code> は遺伝的プログラミングと呼ばれる技術を実行します。
遺伝的プログラミングは、問題を解決する演算子と引数の組み合わせを見つけることを試みます。
たとえば<code>evolve</code>に引数として10を送信すると20を返す演算子の組み合わせを見つけるよう指示することができます。
これは些細なことかもしれませんが、遺伝的プログラミングやその他の進化的アルゴリズムは非常に複雑な問題を解決できます。</p>

<p>リポジトリの*examples*ディレクトリに、<a href="https://ja.wikipedia.org/wiki/%E6%9B%B2%E7%B7%9A%E3%81%82%E3%81%A6%E3%81%AF%E3%82%81">カーブフィッティング</a>機能を進化的に処理する例 (<em>examples/evolving-a-function.cx</em>)があります。</p>

<h1 id="シリアライゼーション">シリアライゼーション</h1>

<p>CXのプログラムは、バイト配列に部分的または完全にシリアライズすることができます。
このシリアライゼーション機能により、プログラムはプログラムイメージ（<a href="#https://ja.wikipedia.org/wiki/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8">システムイメージ</a>に類似）を作成することができ 、プログラムがシリアライズされた正確な状態が維持されます。
これは、シリアライズされたプログラムをデシリアライズして後でその実行を再開できることを意味します。
シリアライゼーションを使用してバックアップを作成することもできます。</p>

<p>CXプログラムは、統合された機能を活用して面白いシナリオを作成することができます。
たとえば、プログラムをシリアライズして自分自身のバックアップを作成し、その機能の1つで<a href="#%e7%b5%b1%e5%90%88%e3%81%95%e3%82%8c%e3%81%9f%e9%80%b2%e5%8c%96%e7%9a%84%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0">進化的アルゴリズム</a> を開始することができます。
進化的アルゴリズムが以前の定義よりも優れた機能を発見した場合、この新しいバージョンのプログラムを保持することができます。
しかし、進化的アルゴリズムの実行結果が良くなかった場合、プログラムは保存されたバックアップに復元することができます。
これらのタスクはすべて自動化できます。</p>

    </article>

    
    
</section>

<footer style="background-color:darkgray;">
    <a href="">SkyCoin Logo</a>
    <p>En, Cn, Ko, Jp</p>
    <nav>
        <div>
            <ul>
                <li>SkyCoin</li>
                <li>
                    <a href="">Team</a>
                </li>
                <li>
                    <a href="">Blog</a>
                </li>
                <li>
                    <a href="https://explorer.skycoin.net/app/blocks/1">Blockchain Explorer</a>
                </li>
            </ul>
        </div>
        <div>
            <ul>
                <li>Technology</li>
                <li>
                    <a href="">SkyWire</a>
                </li>
                <li>
                    <a href="../../../skycoin">SkyCoin</a>
                </li>
                <li>
                    <a href="">SkyMiner</a>
                </li>
            </ul>
        </div>
        <div>
            <ul>
                <li><a href=""></a>Community</li>
                
                    <li><a class="footer__link" href="https://www.skycoin.net/">skycoin.net</a></li>
                
                    <li><a class="footer__link" href="https://github.com/skycoin">Github</a></li>
                
                    <li><a class="footer__link" href="https://twitter.com/skycoinproject">Twitter</a></li>
                
                    <li><a class="footer__link" href="https://reddit.com/r/SkycoinProject">Reddit</a></li>
                
                    <li><a class="footer__link" href="https://t.me/Skycoin">Telegram</a></li>
                
                    <li><a class="footer__link" href="https://explorer.skycoin.net/">Blockchain Explorer</a></li>
                
            </ul>
        </div>
        <div>
            <ul>
                <li>Contact</li>
                <li>
                    <a>Email Us</a>
                </li>
                <li>
                    <a href="https://www.skycoin.net/mailing-list/" target="_blank">Mailing List</a>
                </li>
            </ul>
        </div>
    </nav>
</footer>
    

    <script src="../../../app.js"></script>


  <script>
    var dropdown = document.querySelector('.js-dropdown'),
      list = dropdown.querySelector('.js-dropdown-list'),
      current = dropdown.querySelector('.js-dropdown-current');

    current.addEventListener('click', function(e) {
      list.classList.toggle('header-dropdown__list_show');

      document.addEventListener('click', function(e) {
        if(!dropdown.contains(e.target)) {
          list.classList.remove('header-dropdown__list_show');
        }
      });
    }, false)
  </script>

  <script src="../../../app.js"></script>

  
    <script src="//platform.twitter.com/oct.js" type="text/javascript"></script>
    <script type="text/javascript">
    if (window.twttr) {
      twttr.conversion.trackPid('ny03t', { tw_sale_amount: 0, tw_order_quantity: 0 });
    } </script>
    <noscript>
    <img height="1" width="1" style="display:none;" alt="" src="https://analytics.twitter.com/i/adsct?txn_id=ny03t&p_id=Twitter&tw_sale_amount=0&tw_order_quantity=0" />
    <img height="1" width="1" style="display:none;" alt="" src="//t.co/i/adsct?txn_id=ny03t&p_id=Twitter&tw_sale_amount=0&tw_order_quantity=0" />
    </noscript>
  

</body>
</html>
