<!DOCTYPE html>
<html lang="en-us">
  
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Skywire - Skycoin Meshnet Project | Skycoin Blog</title>
  <link rel="stylesheet" href="../../css/main.css" />
  
    <meta property="og:title" content="Skywire - Skycoin Meshnet Project">
    
    <meta property="og:type" content="article">
    <meta property="article:published_time" content="2017-08-29">
    
    <meta property="og:description" content="">
    <meta property="og:url" content="https://www.skycoin.net/overview/skywire---skycoin-meshnet-project/">
    <meta property="og:site_name" content="Skycoin Blog">
    
    
    <meta property="og:tags" content="Skywire">
    
    <meta property="og:tags" content="Meshnet">
    
    
  
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105234182-1', 'auto');
    ga('send', 'pageview');
    </script>
  
</head>

<body>
<header class="site-header color-light">
	<div class="logo-container">
		<a href="../../" class="logo"><span>Skycoin</span></a>
	</div>
	<nav class="nav">
		<ul>
			
				
				<li class="has-dropdown">
					<span class="nav-link">Technology</span>
					<ul>
						
						<li>
							<a class="dropdown-item nav-item-skywire" href="../../skywire">Skywire</a>
						</li>
						
						<li>
							<a class="dropdown-item nav-item-skycoin" href="../../skycoin">Skycoin</a>
						</li>
						
						<li>
							<a class="dropdown-item nav-item-skyledger" href="../../skyledger">Skyledger</a>
						</li>
						
					</ul>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-whitepapers" href="../../whitepapers/">Whitepapers</a>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-roadmap" href="../../roadmap/">Roadmap</a>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-downloads" href="../../downloads/">Downloads</a>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-blog" href="../../blog/">Blog</a>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-markets" href="../../markets/">Buy Skycoin</a>
				</li>
				
			
		</ul>
	</nav>	
</header>

<section id="main">
	<div class="hero ">
	    <h1 id="title">Skywire - Skycoin Meshnet Project</h1>
    </div>

    <article id="content">
        

<p><img src="https://i.imgur.com/9Jk0gLe.jpg" alt="Skywire: The New Internet" /></p>

<!-- MarkdownTOC autolink="true" bracket="round" -->

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#routing-overview">Routing: Overview</a></li>
<li><a href="#incentives-payment-protocol">Incentives: Payment Protocol</a></li>
<li><a href="#source-routing-link-layer-encryption">Source Routing: Link Layer Encryption</a>

<ul>
<li><a href="#example-protocol-nodes-a-and-b">Example Protocol: Nodes <code>A</code> and <code>B</code></a></li>
<li><a href="#possible-improvements">Possible Improvements:</a></li>
</ul></li>
<li><a href="#ipv4-gateway-bypassing-existing-isps">IPv4 Gateway: Bypassing Existing ISPs</a>

<ul>
<li><a href="#example-one">Example One</a></li>
<li><a href="#example-two">Example Two</a></li>
</ul></li>
<li><a href="#skywire-daemon-services-architecture">Skywire Daemon Services Architecture</a>

<ul>
<li><a href="#example-service-blockchain-sync">Example Service: Blockchain Sync</a>

<ul>
<li><a href="#finding-peers">Finding Peers</a></li>
<li><a href="#sending-and-receiving-messages">Sending and Receiving Messages</a></li>
</ul></li>
</ul></li>
<li><a href="#multi-home-routing-and-link-aggregation">Multi-Home Routing and Link Aggregation</a></li>
<li><a href="#meshnet-routing-store-and-forward">Meshnet Routing: Store and Forward</a></li>
<li><a href="#store-and-forward-capacity-utilization">Store and Forward: Capacity Utilization</a></li>
<li><a href="#store-and-forward-examples">Store and Forward: Examples</a>

<ul>
<li><a href="#example-of-normal-operation">Example of normal operation</a></li>
<li><a href="#example-with-congestion">Example with congestion</a></li>
<li><a href="#example-with-packet-loss">Example with packet loss</a></li>
</ul></li>
<li><a href="#store-and-forward-bandwidth-latency-product">Store and Forward: Bandwidth Latency Product</a></li>
<li><a href="#store-and-forward-capacity-utilization-quality-and-service">Store and Forward: Capacity Utilization, Quality and Service</a></li>
<li><a href="#source-routing-multi-route-mobile-connectivity">Source Routing: Multi-Route Mobile Connectivity</a></li>
<li><a href="#source-routing-guard-nodes">Source Routing: Guard Nodes</a></li>
<li><a href="#source-routing-limitations-of-bgp">Source Routing: Limitations of BGP</a></li>
<li><a href="#virtual-routes-skywire-network-topology-at-scale">Virtual Routes: Skywire Network Topology at Scale</a></li>
<li><a href="#source-routing-virtual-routes-sonet-topology">Source Routing: Virtual Routes, SONET Topology</a></li>
<li><a href="#source-routing-asymmetric-connectivity">Source Routing: Asymmetric Connectivity</a></li>
<li><a href="#source-routing-route-discovery">Source Routing: Route Discovery</a></li>
</ul>

<!-- /MarkdownTOC -->

<h2 id="introduction">Introduction</h2>

<p>Skywire objectives:</p>

<ul>
<li>Increase broadband competition. Provide an alternative to existing ISPs. Span last mile.</li>
<li>Enable communities to build ISPs running on user operated infrastructure.</li>
</ul>

<p>Skywire is a new darknet protocol.</p>

<ul>
<li>Low Latency (as fast as TCP/IP and theoretically faster on native network)</li>
<li>High Performance (designed for video, file sharing and high throughput applications)</li>
<li>Privacy Preserving</li>
<li>Supports Operation Over Wifi (Meshnet)</li>
<li>Supports Clearnet Operation (Darknet/Overlay)</li>
</ul>

<p>Skywire solves the incentive and leeching problem for network deployment.</p>

<ul>
<li>Users receive Skycoins for providing network resources</li>
<li>Users consume coins for consuming network resources</li>
</ul>

<p>Skywire is open access.</p>

<ul>
<li>Anyone with a client is able to connect to any Skywire node</li>
<li>Objective is to create a global open access meshnet</li>
</ul>

<p>Skywire is privacy preserving.</p>

<ul>
<li>The traffic passing through your node cannot be traced back to your IP address</li>
<li>Nodes forwarding traffic can only see the previous and next hop</li>
<li>Third parties passively observing cannot link individual packets to a stream or user</li>
<li>Third parties and forwarding nodes cannot read contents of traffic</li>
</ul>

<h2 id="routing-overview">Routing: Overview</h2>

<p>The Skywire meshnet uses a source-routed store-and-forward protocol.</p>

<p>The core of the overlay network is a series of nodes.</p>

<ul>
<li>Each node is identified by a public key hash</li>
<li>Each node receives messages and forwards messages</li>
<li>Nodes receive coins for forwarding traffic</li>
</ul>

<p>To communicate between nodes <code>A</code> and <code>C</code>, through node <code>B</code>:</p>

<ul>
<li>Node <code>A</code> connects to node <code>B</code> and establishes a Route</li>
<li>Node <code>A</code> extends the route to <code>C</code></li>
<li>Traffic sent over the route on <code>A</code> will arrive at <code>C</code></li>
</ul>

<p>In a route <code>A -&gt; B -&gt; C -&gt; D</code>:</p>

<ul>
<li>Nodes only know previous and next hop in route.</li>
<li><code>C</code> will know that the message passed through <code>B</code> and is addressed to <code>D</code>. <code>C</code> will however not know the identity of <code>A</code>.</li>
<li><code>B</code> cannot infer that <code>A</code> is the origin of the route.</li>
<li><code>C</code> cannot infer that <code>D</code> is the final destination of the message</li>
<li><code>B</code> and <code>C</code> cannot read the content of the message (end to end encryption)</li>
<li>A passive observer not participating in the routing of a particular message cannot gain any information about the contents of the message (link layer encryption).</li>
<li>Multiple messages from multiple routes to the same destination may be bundled, reducing ability of passive observer to perform traffic analysis.</li>
</ul>

<p>In the simplest implementation a route is a 128-bit prefix.
Each node reads the prefix and does a lookup in a table,
to determine the next node to forward the packet to.</p>

<p>The source has complete control over routing.</p>

<ul>
<li>Each node can upgrade its routing protocol independently to suit their needs</li>
<li>Source can optimize network paths for lower latency network paths for VOIP or gaming</li>
<li>Source can optimize network paths for throughput for video and file sharing applications</li>
<li>Source can bundle multiple routes to destination for redundancy, reduced latency and throughput</li>
</ul>

<p>Some applications will bundle multiple parallel routes at application layer for:</p>

<ul>
<li>privacy (gatekeeper nodes, tor type gateway/anon services)</li>
<li>throughput</li>
<li>reduced latency</li>
<li>redundancy</li>
</ul>

<p>This is the core of the Skycoin overlay network. It is very simple, but extremely powerful.
Technical and implementation details will be discussed later.</p>

<p>Skywire simply prefixes a packet with a route ID.</p>

<ul>
<li>Routing is a very simple table lookup</li>
<li>Overhead per packet is constant and does not increase for long routes</li>
</ul>

<p>Notes:</p>

<ul>
<li>The destination does not know the identity of the origin. Identity is no longer at routing layer, but application layer. Identity must be confirmed through public key infrastructure.</li>
<li>Man-in-middle attacks are not possible. A source can verify the destination through their public key.</li>
<li>Privacy is significantly improved from IPv4, where anyone handling a packet can see the destination, the source and contents of the packet.</li>
<li>Performance is superior to IPv4/BGP because ISPs use hot potato routing.</li>
<li>End-to-End encryption eliminates packet injection attacks and spoofing. Spoofing traffic requires the private keys for each end of the connection tunnel.</li>
<li>Encryption is fast. Objective is 10 Gb/s throughput on FPGA hardware, 200 Mb/s on ARM.</li>
</ul>

<h2 id="incentives-payment-protocol">Incentives: Payment Protocol</h2>

<p><img src="https://i.imgur.com/2zj4CUV.jpg" alt="Skywire miner" /></p>

<p><em><a href="../../statement/skywire-miner-hardware-for-the-next-internet/">Skywire &ldquo;miner&rdquo;</a></em></p>

<p>Nodes want to forward traffic and receive coins. This is the equivalent of “mining” in Skycoin and how many users will get their first coins.</p>

<p>Payments for transit should not reveal the identity of the source node. Skycoin will use blinded escrow payments through a third party until a better protocol is developed.</p>

<p>Each node in route records traffic and the origin node records traffic. They settle bandwidth payments periodically.</p>

<p>The origin holds coins in escrow with a third party. A pseudonym account is created with the third party. Each node can verify reputation of the origin and payment ability through the third party, without learning identity of party. To the third party, each origin will appear as multiple unlinked pseudonym accounts. Each transit node will appear as multiple unlinked pseudonym accounts.</p>

<p>Small transactions will be settled internally, in off-blockchain transactions. The off-blockchain transactions can be withdrawn into a newly generated, never used before address once the balance exceeds a threshold (currently 1 Skycoin). This reduces blockchain bloat and encourages microtransactions to be performed off-blockchain.</p>

<h2 id="source-routing-link-layer-encryption">Source Routing: Link Layer Encryption</h2>

<p>There is a default link layer encryption between hops and default end-to-end encryption. A typical application will use link layer encryption, end-to-end encryption and then appropriate application layer encryption.</p>

<p>Encryption between nodes should be fast. FPGA implementations must support 10 Gb/s operation at line speed. ARM processors must be able to support 250 Mb/s.</p>

<p>The current best candidate is ChaCha20 with ECC secp256k1 ephemeral key exchange.</p>

<p>ChaCha20 only uses simple arithmetic operations, is faster than AES for embedded devices and is more resistant to timing channel attacks than AES.</p>

<p>A modern CPU can perform 6000 secp256k1 ECDH operations per second. Session key rotation should be once per second or twice the round trip latency between nodes. There should be a separate key for each direction of communication.</p>

<p>The previous session key should be accumulated into the secret received via ECDH.</p>

<p>The session key, established through public key cryptography (ECC) is used to encrypt communications using a faster asymmetric encryption algorithm (AES, ChaCha20). This the basic link layer encryption between nodes.</p>

<h3 id="example-protocol-nodes-a-and-b">Example Protocol: Nodes <code>A</code> and <code>B</code></h3>

<ul>
<li>Node <code>A</code> wants to generate session key for sending encrypted data to node <code>B</code></li>
<li>Node <code>B</code> has public key <code>P</code>, with private key <code>p</code>. <code>P</code> is a point on the ECC sep256k1 curve. <code>p</code> is a 256 bit integer. <code>P</code> is the basepoint b, raised to the power of p with the curve addition operation.</li>
<li>Node <code>A</code> generates an ephemeral public key <code>Q</code>, with private key <code>q</code>. (Node <code>A</code> randomly generates a 20 byte integer. This is the private key <code>q</code>. Node <code>A</code> raises the base point to the power of <code>q</code>, to generate the private key <code>Q</code>, which is a point on the curve).</li>
<li>Node <code>A</code> sends, <code>P</code>*<code>q</code> (the point on curve <code>P</code>, which is <code>B</code>’s public key, raised to power of <code>q</code>)</li>
<li>Node <code>A</code> sends <code>P</code> to node <code>B</code></li>
<li>Node <code>B</code> receives <code>P</code> and computes <code>P*q</code>, Node <code>A</code> can compute <code>p*Q</code>, which are equal. This is the shared secret, which is hashed to generate session key.</li>
<li><code>P = b*q</code>, so <code>P*q</code> is equal to <code>(b*p)*q</code>.  <code>P*q = (b*p)*q = (b*q)*p = Q*p</code>, since <code>Q=b*q</code>. <code>A</code> knows <code>q,Q</code> and <code>P</code>, and <code>B</code> knows <code>p,P</code> and <code>Q</code>. So <code>A</code> and <code>B</code> can both compute <code>P*q</code> and <code>Q*p</code> and use this as their secret. However, a third party does not know the private keys <code>q</code> for <code>A</code> nor know the private key <code>p</code> for <code>B</code>, so a third party cannot compute this “secret” and therefore cannot read anything encrypted under the secret.</li>
<li>Node <code>B</code> confirms receipt of the session key update. Node <code>A</code> begins transmitting under the new session key as soon as the confirmation is received from <code>B</code>.</li>
<li>Node <code>A</code>, sends messages to node <code>B</code> by encrypting them using ChaCha20 using the session key, as the asymmetric encryption key.</li>
</ul>

<h3 id="possible-improvements">Possible Improvements:</h3>

<ul>
<li>Frequent session key updates. ECDH key exchange every few seconds or minutes.</li>
<li>Hash old session key with new ECDH secret to generate new session key.</li>
<li>Add nonces to packets and hash secret into nonce to generate key for each message. Same key is never reused. Reduces impact of known plaintext attack.</li>
<li>Eliminate known plain text in messages.</li>
<li>Pad messages to multiples of 16 or 32 bytes.</li>
</ul>

<h2 id="ipv4-gateway-bypassing-existing-isps">IPv4 Gateway: Bypassing Existing ISPs</h2>

<p>Many people have only a single choice for ISPs. This briefly describes how Skywire can increase competition.</p>

<p>Some applications can run natively on the Skywire address space. Some applications such as Bittorrent, file syncing and communication applications strongly benefit from the Skywire infrastructure and will be modified to run natively on it.</p>

<p>Legacy applications, such as Netflix, Facebook, Twittter require a network gateway interfacing the Skywire overlay network with IPv4 and IPv6 networks.</p>

<p>A user chooses a Skywire gateway running on a server in a local colocation center. The users IPv4 traffic will be tunneled through the gateway (similar to a VPN). The users IP will appear as the IP of the gateway server . The server has a gigabit connection to multiple fast internet backbones, on providers which do not rate limit Netflix. The user has multiple choices of providers for Skywire IPv4 gateways. The gateway provider will be paid in Skycoin on a metered basis.</p>

<p>The Skywire node in the users home connects to the gateway over all possible routes. The Skywire node tunnels the IPv4 traffic from a router to the gateway in the colocation center. The IP address of the gateway node is the IP address that appears to the user.</p>

<h3 id="example-one">Example One</h3>

<p>A user has a 10 Mb/s cable modem. They install a Skywire router. The router is plugged into their computer, into a Skywire Wifi node and into their cable model. The router is configured with Skywire as a IPv4 tunnel. They plug their computer into the router.</p>

<p>The Skywire wifi node connects to their neighbors Skywire node over wifi, which is connected to a 10 Mb/s cable modem. The neighbor also has a 200 Mb/s 5 GHz wifi with directional point-to-point antenna connected to a business running a Skywire wifi node down the street.</p>

<p>The users Skywire router does a recursive breadth first search for nodes with clearnet connectivity and establish routes over</p>

<ul>
<li>His cable modem</li>
<li>Wifi -&gt; his neighbors cable modem</li>
<li>Wifi -&gt; 5 GHz point to point -&gt; <sup>100</sup>&frasl;<sub>30</sub> Mb/s business/fiber drop</li>
</ul>

<p>The user will be able to access and aggregate bandwidth over all routes, in connecting to the IPv4 tunnel. In communities where aggregate bandwidth and reliability have reached a certain level, the user no longer needs the cable modem for connectivity.</p>

<h3 id="example-two">Example Two</h3>

<p>The business down the street has a <sup>100</sup>&frasl;<sub>30</sub> Mb/s fiber drop with an SLA. The business pays a fixed rate for internet. Any bandwidth they do not use is lost. The business hooks up a Skywire router. The router has 3 ports. The first port is their WAN connection, the second port is their internal network, the third port goes to their Skywire wifi nodes on roof. The router buffers and prioritizes traffic on the internal network and allocates unused capacity to the Skywire traffic. The operator receives Skycoins for transit which, subsidizes the cost of the fiber drop.</p>

<h2 id="skywire-daemon-services-architecture">Skywire Daemon Services Architecture</h2>

<ul>
<li>Each Skycoin node has a Secpk256k1 pubkey.</li>
<li>Each Skycoin node has a Skycoin address identifying it. The address is a hash of the node’s public key. This public key hash is the equivalent of an IP address on the network.</li>
<li>Each Skycoin node has a connection pool of peers it is connected to. These can be peers over TCP, UDP clearnet connections, physical connections through direct Ethernet and Wifi peer (meshnet operation). A connection can also be a “virtual connection” which is tunneled through a physical or clearnet connection and will be described later.</li>
<li>Each connection instance with a peer has “channels”. A channel is a 16 bit integer which is similar to a “port” in TCP.</li>
<li>All messages sent and received have a 32 bit length prefixed and 16 bit channel.</li>
<li>Channel 0 is reserved for communication between Skywire Daemons,  exposing meta-information about the services running on the Daemon and other data required for network operation.</li>
<li>A Skywire daemon may expose “services” on a channel. A service is a process that handles data messages received on a channel and originates data messages addressed to remote peers and services.</li>
</ul>

<h3 id="example-service-blockchain-sync">Example Service: Blockchain Sync</h3>

<p><em>This example is refers to a Golang implementation, but the daemon architecture is language agnostic.</em></p>

<p>You want to sync two different personal block chains of people with public keys A and B. You initiate two “blockchain sync service” instances, configure them with the respective public keys and associate them with the Skycoin Daemon. These services run on your local daemon, each on a particular channel.</p>

<h4 id="finding-peers">Finding Peers</h4>

<p>The blockchain sync daemons the hash the public key and do a DHT (Distributed Hash Table) lookup to find other peers syncing the blockchain. Once peers are found, the peers can be introduce each other to additional peers through PEX (Peer Exchange).</p>

<h4 id="sending-and-receiving-messages">Sending and Receiving Messages</h4>

<p>Services on creation register a list of messages they respond to and can send. Messages are Golang structs. The message struct data is filled out and then sent. The data arrives and the .Handle() method is called on the corresponding message struct.</p>

<h2 id="multi-home-routing-and-link-aggregation">Multi-Home Routing and Link Aggregation</h2>

<p>If you have a 2 Mb/s cable modem and your neighbor has a 2 Mb/s cable modem and each of you are running Skywire nodes, then your Skywire node can connect to his node and aggregate the bandwidth across both connections. Packets may now take routes through your cable modem and routes through his cable modem. The cable modems are the choke point. To get a 4 Mb/s connection, traffic has to pass in parallel paths through both modems.</p>

<p>Applications like Bittorrent will be able to aggregate bandwidth across all available connections, because they natively open up a large number of connections, which will take district routes.</p>

<h2 id="meshnet-routing-store-and-forward">Meshnet Routing: Store and Forward</h2>

<p>For nodes at the edge of the network communicating over mesh, there are a few issues.</p>

<p>If you have an eight hop network over Wifi and 50% of packets drop on each hop, then only 1 in 256 packets will make it through. Packet drop is normal on Wifi, but traditional TCP treats packet drop as congestion and throttles the connection speed back.</p>

<p>At the network edge, Skywire will use store and forward along routes. This imposes a memory requirement on Skywire nodes, but significantly improves network performance.</p>

<p>For the route <code>A-&gt;B-&gt;C</code></p>

<ul>
<li>Each route has a buffer.</li>
<li>Each node keeps sending the messages until they are received and acknowledged.</li>
<li>If the Buffer from <code>B-&gt;C</code> is full for the route, then <code>A</code> will know this and will stop transmitting data until the sent data has been acknowledged there is room in the buffer.</li>
</ul>

<p>Therefore there are two acknowledgements between nodes at the link layer. One acknowledgement is an affirmative acknowledgement that transmitted data segments were received. Another is an acknowledgment that data from the buffer has been sent to and acknowledged by the next node in the route.</p>

<h2 id="store-and-forward-capacity-utilization">Store and Forward: Capacity Utilization</h2>

<p>In traditional IP networks, as network links are utilized towards capacity the efficiency drops. A network running at 80% capacity faces the risk that a short term burst of data causes a router to go over capacity and network packets are dropped.</p>

<p>TCP interprets dropped packets for any reason as congestion and throttles back speed. The dropped packets also require retransmission under TCP and introduce latency as the application waits for timeout and retransmission before it can process the rest of the packet stream.</p>

<p>With store and forward operation, the route buffers fill up and then nothing happens. When the buffers fill, the incoming node stop sending data until notified of space in the buffer.</p>

<p>This store and forward operation is especially important for practical Wifi meshnets. There are only three non-overlapping channels in the 2.4 GHz band. Packet loss increases very quickly and very early compared to the bandwidth saturation point for a Wifi networks. Wifi packet loss is inevitable and does not reliably indicate congestion or capacity limits.</p>

<p>Store and forward allows us to run the Wifi nodes at full capacity and saturate all available bandwidth, without triggering TCP congestion controls.</p>

<p>Practical networks will require:</p>

<ul>
<li>Software Defined Radio</li>
<li>MIMO</li>
<li>Beam Forming</li>
<li>Directional Antennas</li>
<li>Cooperative temporal and geophysical coordination of transmission time, broadcast power and frequency usage</li>
<li>801.11af whitespace frequencies</li>
</ul>

<h2 id="store-and-forward-examples">Store and Forward: Examples</h2>

<p>Each node, for each route keeps track of:</p>

<ul>
<li>Buffer size for receiving node for route</li>
<li>Predicted buffer size (acked and unacked datasegments transmitted)</li>
<li>Acked buffer size</li>
<li>Offset, size and sequence of each transmitted message that has not been acked</li>
<li>Circular buffer of bytes of outgoing datagrams that have not received an ack</li>
</ul>

<p>A data segment on the link layer may contain concatenated messages, from multiple routes addressed to the same node. This frustrates traffic analysis and improves performance by allowing larger datagrams on networks which support higher MTUs.</p>

<p>For each transmitted message, there are two acks. The first ack is that the datagram has been received by the next node in route. This is an ack for the datagram, which may contain multiple messages, each corresponding to different routes. After receiving this ack, the node no longer needs to retain the datagram. If the datagram is not acked, then it needs to be resent.</p>

<p>The second ack are updates about remaining free bytes in the incoming buffer for a route. If the free bytes in the buffer for a route is large enough, then additional messages for that route can be transmitted.</p>

<p>Another possible approach, maintains a buffer per sender instead of per route, with the receiver sending block messages to the sender for congested routes. This reduces the number of route hash lookups required by sender and is something that may have to be experimented with.</p>

<h3 id="example-of-normal-operation">Example of normal operation</h3>

<p>Route: <code>A-&gt;B-&gt;C</code></p>

<ul>
<li>B has 1024 KB buffer for route</li>
<li>A sends 512 KB to B</li>
<li>B Acknowledges the 512 KB to A</li>
<li>&lt; A receives the Acknowledgement (and clears first 512 KB, no longer needs to be stored) &gt;</li>
<li>B forwards 512 KB to C</li>
<li>C acknowledges receipt of the 512 KB</li>
<li>C acknowledges to A that the 512 KB has been forwarded</li>
</ul>

<h3 id="example-with-congestion">Example with congestion</h3>

<p>Route: <code>A-&gt;B-&gt;C</code></p>

<ul>
<li>B has 1024 buffer for route</li>
<li>A sends 512 KB to B</li>
<li>A sends 256 KB to B</li>
<li>A sends 256 KB to B</li>
<li>&lt; A stops sending because pending, is already enough to fill buffer at B &gt;</li>
<li>B acknowledges to A the receipt of 512 KB and 512 KB</li>
<li>B sends 256 KB to C</li>
<li>C acknowledges receipt of 256 KB to B</li>
<li>B acknowledges to B, forwarding of 256 KB to A</li>
<li>&lt; A can now send, up to 256 KB additional KB &gt;</li>
</ul>

<p>Data is assumed to be received in the order sent for Wifi and direct ethernet connection</p>

<h3 id="example-with-packet-loss">Example with packet loss</h3>

<p>Route: <code>A-&gt;B-&gt;C</code></p>

<ul>
<li>B has 1024 buffer for route</li>
<li>A sends 512 KB to B</li>
<li>A sends 256 KB to B</li>
<li>B acks the 256 KB</li>
<li>A infers that the 512 KB was not received</li>
<li>A retransmits the 512 KB</li>
<li>B acks the 512 KB</li>
<li>&lt; B can now continue sending stream in order to C &gt;</li>
</ul>

<h2 id="store-and-forward-bandwidth-latency-product">Store and Forward: Bandwidth Latency Product</h2>

<p>In store and forward a storage requirement is imposed on the transmitting node equal to the product of the round trip latency and the transmission rate times the round trip latency. 1 GB of ram is enough for 8000 ms round trip latency at 1 Gb/s transmission rate.</p>

<p>Store and forward should be default, but optional.</p>

<h2 id="store-and-forward-capacity-utilization-quality-and-service">Store and Forward: Capacity Utilization, Quality and Service</h2>

<p>Video, Audio and file downloads are buffered. Absolute averaged throughput over a time window of seconds matters, while latency is irrelevant. Other traffic such as website requests, video game and voip is real time and should be delivered as quickly as possible.</p>

<p>With two quality of service levels, “Real Time” and “Bulk” we can transmit VOIP, website and video game traffic first, reducing latency for this traffic. Latency insensitive traffic such as video, music and file sharing would only flow over link after real time traffic buffer is empty.</p>

<p>We are able to utilize links at near 100% of capacity while, lowering latency for real time traffic. Therefore we propose supporting two quality of service levels for routes.</p>

<h2 id="source-routing-multi-route-mobile-connectivity">Source Routing: Multi-Route Mobile Connectivity</h2>

<p>If connections between nodes are stable, low latency and have high bandwidth then a single route is sufficient for most applications. Some applications like Bitorrent, open a large number of connections and natively can use bandwidth across all available routes.</p>

<p>If the links between nodes are slow, unreliable or connectivity is changing, reliability and performance requires traffic to be multiplexed over multiple redundant routes.</p>

<p>If a Skywire node running on a cell phone is in a car driving down the street, the networks that are accessible will change. Network nodes will come into range and other network nodes will leave range. The node should have continuous connectivity at the application layer, even as the physical connections are created and destroyed.</p>

<p>One approach is choosing a set of reliable nodes on the network backbone as termination points for a route and then proxying the traffic through these nodes, over a set of multiple short term routes.</p>

<h2 id="source-routing-multi-route-reliability">Source Routing: Multi-Route Reliability</h2>

<p>If links are unreliable or have highly variable latency, it is desirable to encode application data over multiple paths, such that the data can be recovered if data from any of the paths is received. Fountain coding and other encoding methods exist which may be applicable here.</p>

<h2 id="source-routing-guard-nodes">Source Routing: Guard Nodes</h2>

<p>For privacy, if a user wants to further weaken linkability between their Skywire node address (public key hash) to their IP address, they can destinate a fixed set of nodes that are advertised as being transit points for traffic destined for their address or act as required nodes on a route from their address.</p>

<h2 id="source-routing-limitations-of-bgp">Source Routing: Limitations of BGP</h2>

<p>Border Gateway Protocol, the current dominant routing protocol, handles the routing problem by not keeping any state for packets. Instead BGP, allows each network to create a series of ad-hoc rules for each of its routers which look at the source and destination of a packet and decide which network interface to forward the packet to. Routers message each other with connectivity information and another routing algorithm is used for routing within a network domain.</p>

<p>BGP is designed to interface a series of independent autonomous networks. BGP has a homogeneity assumption, the routing within an autonomous domain is assumed to be centrally managed and highly reliable with homogenous routing within the domain. Mesh network and community ISPs will be ad-hoc with heterogeneous device connectivity and routing.</p>

<p>Connectivity in mesh networks, ad-hoc configurations and densely interconnected networks with redundant multi-home routing paths completely violate the hierarchical assumptions BGP.</p>

<p>BGP has several issues that a next gen protocol should address:</p>

<ul>
<li>BGP is not self configuring. BGP based networks require extensive technical expertise to configure and operate</li>
<li>BGP systems often require manual configuration to route around damage and are not resilient against bad configurations</li>
<li>BGP requires manual creation of ad-hoc route filtering rules and increasing complexity for networks with multi-home connectivity</li>
<li>BGP networks require highly centralized planning</li>
<li>The NSA has exploited flaws in BGP to route targeted traffic to interception points</li>
<li>The assumptions of BGP are becoming increasingly strained, especially for ad-hoc, mesh and mobile networks</li>
<li>The hierarchical, single path assumptions of BGP make implementation of multi-homing and other next-gen networking requirements extremely difficult</li>
<li>BGP suffers severe issues when network links are unreliable, such as route flapping.</li>
<li>BGP routing table size grows exponentially as interconnected subnetworks proliferate.</li>
<li>Multihoming causes a massive explosion in BGP routing table size.</li>
<li>BGP has difficulty with load balancing and multi-home routing. BGP limits the ability in practical networks to take advantage of parallel connectivity between locations.</li>
<li>BGP creates an incentive for ISPs to dump network traffic on to other networks as quickly as possible (“Hot Potato Routing”), reducing performance and increasing latency</li>
</ul>

<p>There is no alternative to BGP. BGP is the best solution within its design constraints.</p>

<p>The successor to BGP must:</p>

<ul>
<li>Be non-hierarchical</li>
<li>Be self-configuring (zero-conf)</li>
<li>Operate well with dense ad-hoc, redundant interconnection between networks</li>
</ul>

<h2 id="virtual-routes-skywire-network-topology-at-scale">Virtual Routes: Skywire Network Topology at Scale</h2>

<p>The Skywire routing implementation requires a node to maintain information for each route that passes through it. Individual nodes are unable to handle hundreds of thousands of individual routes and scalability is achieved through another mechanism.</p>

<p>Skywire is experimenting with a non-hierarchical, self organizing routing that natively supports multihoming and non-hierarchical network topographies while scaling efficiently.</p>

<p>Skywire minimizes network diameter as the network scales through the use of virtual routes. Virtual routes allow thousands of connections to be bundled over a high bandwidth backbone connection with the overhead of a single route.</p>

<p>A “virtual route” creates a tunnel over an existing route:</p>

<p><code>A -&gt; B -&gt; C -&gt; D</code></p>

<p>The virtual route appears as A-&gt;D. B and C may be high bandwidth long distance connections. B and C only incur the overhead of a single route, while A and D incur the overhead of maintaining the routes on the A-&gt;D tunnel.</p>

<p>The virtual route may contain traffic from hundreds of bundled routes from A to D, while B and C only experience overhead of a single route. The virtual route may further, bundle multiple redundant network paths between the origin and destination for performance, throughput and redundancy.</p>

<p>Virtual routes allow network capacity to be clustered roughly hierarchically with nodes at each layer having a constant fan in and overhead.</p>

<p>Nodes at the network edge feed into aggregation nodes. Edge aggregation nodes are connected to high bandwidth intradomain transit and feed into gateway nodes which interface between networks. Gateway nodes feed into high bandwidth and long-haul transit.</p>

<p>Virtual routes are a representation of existing interdomain routing relationships, which natively support:</p>

<ul>
<li>Non-hierarchical routing (data centers)</li>
<li>Multiple-homing</li>
<li>Dense network interconnection between domains at different levels of hierarchy</li>
<li>Multi-path routing within and between network domains</li>
</ul>

<p>Virtual routes obey a triangle equality. If the cost of a route A-&gt;B, is C(A-&gt;B) then</p>

<p><code>C(A-&gt;B-&gt;C) &gt;= C(A-&gt;B) + C(B-&gt;C)</code></p>

<p>Origin preference for low latency, low cost, and low hop routes, creates economic incentives to create an efficient network topology. The network is non-hierarchical and self-organizing. The virtual routes that are created are route summarizations that naturally reflect the flow of traffic.</p>

<p>In BGP, networks try to get rid of traffic as quickly as possible (hot potato routing). In Skywire, networks compete to provide transit (to receive coin incentives). Skywire clients will preference, low cost, low hop count and low latency routes. Networks with direct long haul capacity between source and destination have lower latency and lower hop count and therefore receive preference.</p>

<p>For efficiency, the bandwidth capacity and fan-in (number of routes each virtual route is bundling) at each level of the network hierarchy must be constant, in order to achieve a constant network diameter and logarithmic routing table growth in the number of hosts.</p>

<h2 id="source-routing-virtual-routes-sonet-topology">Source Routing: Virtual Routes, SONET Topology</h2>

<p>A multiple-input, multiple-output virtual route, may be physically implemented as a SONET ring, with Skywire nodes in each city the SONET topology passes through. The Skywire nodes act as a gateway router between the Skywire network and the SONET topology.</p>

<p>Nodes are able to queue up large datagrams concatenating multiple messages from the same source to the same destination for efficiency.</p>

<p>The message enters the Skywire node of the SONET ring at a colocation center in one city. The message destination or route is read and the message is encoded for transport over the SONET segment. The message arrives at the destination Skywire node on the SONET segment and continues on its path.</p>

<p>A multiple input, multiple output virtual route is therefore a list of Skywire nodes, with a transit cost, describing a SONET ring or fully connected topology, where any node in list has transit to any other node in the list.</p>

<h2 id="source-routing-asymmetric-connectivity">Source Routing: Asymmetric Connectivity</h2>

<p>Next gen wifi systems will have 4x4 and 8x8 antennas in a phased array MIMO arrangement. Such systems are able to project highly focused directional beams. These systems significantly increase the power and signal strength at the receiver, but do not symmetrically improve antenna gain for return signals.</p>

<p>Similarly, a high powered, amplified wifi signal through a directional antenna may be received at a site fifteen miles away, but reception of the signal from the site cannot similarly be amplified as easily as power can be boosted in transmission.</p>

<p>We propose, Asymmetric routes, for situations where messages can be received by a node, but where the node cannot directly communicate back. In an asymmetric route, confirmation messages are relayed over the network by a route, enabling full utilization of asymmetric connectivity over one way communication channels.</p>

<p>Situations where this will become increasingly relevant</p>

<ul>
<li>Rural SONET arrangements with amplified Wifi over directional antennas</li>
<li>Urban connectivity between highly directional and non-directional antennas broadcasting at the same power levels</li>
<li>Concrete penetration in 802.11af systems</li>
<li>Non-line of sight LiFi propagation can transmit over 200 Mb/s but its highly asymmetrical</li>
<li>RONJA type Li-Fi systems have theoretical capacity limits over 10 Gb/s line-of-sight and there is cost/setup advantage for asymmetrical connectivity</li>
</ul>

<p>Utilizing asymmetric connectivity and routes allowing only one way direct data transmission between nodes has several advances, especially for rural developments and reducing cost of integrating high capacity of next-gen technologies.</p>

<h2 id="source-routing-route-discovery">Source Routing: Route Discovery</h2>

<p>IPv4 gateway and meshnets for community ISPs, only require breadth first search over paths to clearnet connectivity. The best, most reliable, highest throughput routes have very small depth. Therefore we consider routing solved for this case. Will look at general routing later.</p>

    </article>

    
    
</section>

<footer style="background-color:darkgray;">
    <a href="">SkyCoin Logo</a>
    <p>En, Cn, Ko, Jp</p>
    <nav>
        <div>
            <ul>
                <li>SkyCoin</li>
                <li>
                    <a href="">Team</a>
                </li>
                <li>
                    <a href="">Blog</a>
                </li>
                <li>
                    <a href="https://explorer.skycoin.net/app/blocks/1">Blockchain Explorer</a>
                </li>
            </ul>
        </div>
        <div>
            <ul>
                <li>Technology</li>
                <li>
                    <a href="">SkyWire</a>
                </li>
                <li>
                    <a href="../../skycoin">SkyCoin</a>
                </li>
                <li>
                    <a href="">SkyMiner</a>
                </li>
            </ul>
        </div>
        <div>
            <ul>
                <li><a href=""></a>Community</li>
                
                    <li><a class="footer__link" href="https://www.skycoin.net/">skycoin.net</a></li>
                
                    <li><a class="footer__link" href="https://github.com/skycoin">Github</a></li>
                
                    <li><a class="footer__link" href="https://twitter.com/skycoinproject">Twitter</a></li>
                
                    <li><a class="footer__link" href="https://reddit.com/r/SkycoinProject">Reddit</a></li>
                
                    <li><a class="footer__link" href="https://t.me/Skycoin">Telegram</a></li>
                
                    <li><a class="footer__link" href="https://explorer.skycoin.net/">Blockchain Explorer</a></li>
                
            </ul>
        </div>
        <div>
            <ul>
                <li>Contact</li>
                <li>
                    <a>Email Us</a>
                </li>
                <li>
                    <a href="https://www.skycoin.net/mailing-list/" target="_blank">Mailing List</a>
                </li>
            </ul>
        </div>
    </nav>
</footer>
    

    <script src="../../app.js"></script>


  <script>
    var dropdown = document.querySelector('.js-dropdown'),
      list = dropdown.querySelector('.js-dropdown-list'),
      current = dropdown.querySelector('.js-dropdown-current');

    current.addEventListener('click', function(e) {
      list.classList.toggle('header-dropdown__list_show');

      document.addEventListener('click', function(e) {
        if(!dropdown.contains(e.target)) {
          list.classList.remove('header-dropdown__list_show');
        }
      });
    }, false)
  </script>

  <script src="../../app.js"></script>

  
    <script src="//platform.twitter.com/oct.js" type="text/javascript"></script>
    <script type="text/javascript">
    if (window.twttr) {
      twttr.conversion.trackPid('ny03t', { tw_sale_amount: 0, tw_order_quantity: 0 });
    } </script>
    <noscript>
    <img height="1" width="1" style="display:none;" alt="" src="https://analytics.twitter.com/i/adsct?txn_id=ny03t&p_id=Twitter&tw_sale_amount=0&tw_order_quantity=0" />
    <img height="1" width="1" style="display:none;" alt="" src="//t.co/i/adsct?txn_id=ny03t&p_id=Twitter&tw_sale_amount=0&tw_order_quantity=0" />
    </noscript>
  

</body>
</html>
