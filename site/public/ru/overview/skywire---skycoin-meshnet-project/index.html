<!DOCTYPE html>
<html lang="en-us">
  
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Skywire - Проект Ячеистой Сети Skycoin | Skycoin Блог</title>
  <link rel="stylesheet" href="../../../css/main.css" />
  
    <meta property="og:title" content="Skywire - Проект Ячеистой Сети Skycoin">
    
    <meta property="og:type" content="article">
    <meta property="article:published_time" content="2017-08-29">
    
    <meta property="og:description" content="">
    <meta property="og:url" content="https://www.skycoin.net/ru/overview/skywire---skycoin-meshnet-project/">
    <meta property="og:site_name" content="Skycoin Блог">
    
    
    <meta property="og:tags" content="Skywire">
    
    <meta property="og:tags" content="Meshnet">
    
    
  
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105234182-1', 'auto');
    ga('send', 'pageview');
    </script>
  
</head>

<body>
<header class="site-header color-light">
	<div class="logo-container">
		<a href="../../../" class="logo"><span>Skycoin</span></a>
	</div>
	<nav class="nav">
		<ul>
			
				
				<li class="has-dropdown">
					<span class="nav-link">Technology</span>
					<ul>
						
						<li>
							<a class="dropdown-item nav-item-skywire" href="../../../ru/skywire">Skywire</a>
						</li>
						
						<li>
							<a class="dropdown-item nav-item-skycoin" href="../../../ru/skycoin">Skycoin</a>
						</li>
						
						<li>
							<a class="dropdown-item nav-item-skyledger" href="../../../ru/skyledger">Skyledger</a>
						</li>
						
					</ul>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-whitepapers" href="../../../ru/whitepapers/">Whitepapers</a>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-roadmap" href="../../../ru/roadmap/">Roadmap</a>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-downloads" href="../../../ru/downloads/">Downloads</a>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-blog" href="../../../ru/blog/">Blog</a>
				</li>
				
			
				
				<li>
					<a class="nav-link nav-item-markets" href="../../../ru/markets/">Buy Skycoin</a>
				</li>
				
			
		</ul>
	</nav>	
</header>

<section id="main">
	<div class="hero ">
	    <h1 id="title">Skywire - Проект Ячеистой Сети Skycoin</h1>
    </div>

    <article id="content">
        

<ul>
<li><a href="#Введение">Введение</a></li>
<li><a href="#Маршрутизация-Обзор">Маршрутизация: Обзор</a></li>
<li><a href="#Стимулирование-Протокол-Платежей">Стимулирование: Протокол Платежей</a></li>
<li><a href="#Маршрутизация-от-источника-Канальное-шифрование">Маршрутизация от источника: Канальное шифрование</a>

<ul>
<li><a href="#Пример-протокола-ноды-A-и-b">Пример протокола: ноды <code>A</code> и <code>B</code></a></li>
<li><a href="#Возможные-улучшения">Возможные улучшения:</a></li>
</ul></li>
<li><a href="#IPv4-шлюз-обход-существующих-интернет-провайдеров">IPv4 шлюз: обход существующих интернет-провайдеров</a>

<ul>
<li><a href="#Пример-один">Пример один</a></li>
<li><a href="#Пример-два">Пример два</a></li>
</ul></li>
<li><a href="#Архитектура-демона-Skywire">Архитектура демона Skywire</a>

<ul>
<li><a href="#Пример-сервиса-синхронизация-блокчейна">Пример сервиса: синхронизация блокчейна</a></li>
</ul></li>
<li><a href="#Маршрутизация-нескольких-сетей-и-объединение-каналов">Маршрутизация нескольких сетей и объединение каналов</a></li>
<li><a href="#Маршрутизация-ячеистой-сети-Хранение-и-пересылка">Маршрутизация ячеистой сети: Хранение и пересылка</a></li>
<li><a href="#Хранение-и-пересылка-использование-емкости">Хранение и пересылка: использование емкости</a></li>
<li><a href="#Хранение-и-пересылка-примеры">Хранение и пересылка: примеры</a>

<ul>
<li><a href="#Пример-обычной-операции">Пример обычной операции</a></li>
<li><a href="#Пример-с-переполнением">Пример с переполнением</a></li>
<li><a href="#Пример-с-потерей-пакета">Пример с потерей пакета</a></li>
</ul></li>
<li><a href="#Хранение-и-пересылка-задержки-и-пропускная-способность">Хранение и пересылка: задержки и пропускная способность</a></li>
<li><a href="#Хранение-и-пересылка-использование-пропускной-способности-и-качество-обслуживания">Хранение и пересылка: использование пропускной способности, качество и обслуживание</a></li>
<li><a href="#Маршрутизация-от-источника-множественные-маршруты-для-мобильного-подключения">Маршрутизация от источника: множественные маршруты для мобильного подключения</a></li>
<li><a href="#Маршрутизация-от-источника-ноды-стражи">Маршрутизация от источника: ноды-стражи</a></li>
<li><a href="#Маршрутизация-от-источника-ограничения-BGP">Маршрутизация от источника: ограничения BGP</a></li>
<li><a href="#Виртуальные-маршруты-масштабирование-топологии-сети-Skywire">Виртуальные маршруты: масштабирование топологии сети Skywire</a></li>
<li><a href="#Маршрутизация-от-источника-виртуальные-маршруты-и-топология-SONET">Маршрутизация от источника: виртуальные маршруты и топология SONET</a></li>
<li><a href="#Маршрутизация-от-источника-асимметричные-соединения">Маршрутизация от источника: асимметричные соединения</a></li>
<li><a href="#Маршрутизация-от-источника-открытие-маршрутов">Маршрутизация от источника: открытие маршрутов</a>
 </li>
</ul>

<p> </p>

<h2 id="введение">Введение</h2>

<p> 
Объекты Skywire:
 
* Улучшают высокороскоростной доступ к контенту. Предоставляют альтернативу существующим ISP (Internet Service Provider -
провайдеры интернета). Решение &ldquo;последней мили&rdquo;.
* Позволяют сообществу строить ISP, используя управляемую пользователем инфраструктуру.
 </p>

<p>Skywire это новый протокол даркнета.
 
* Низкая латентность (также быстр как TCP/IP и теоретически быстрее обычной сети)
* Высокая производительность (разработан для передачи видео, файлов и работы высоконагруженных трафиком приложений)
* Обеспечивает конфиденциальность
* Поддерживает связь через WiFi (Meshnet)
* Поддерживает операции обычного интернета (Darknet/Overlay)</p>

<p> 
Skywire решает проблемы стимулирования и безвозмедного потребления ресурсов при развертвывании сети.
 
* Владельцы узлов получают токены Skycoin для обеспечения доступности ресурсов сети
* Пользователи сети используют токены для потребления сетевых ресурсов</p>

<p> 
Доступ к Skywire открыт.
 
* Каждый, кто установил клиентское приложение, может связаться с любой нодой Skywire
* Объекты создают глобальную ячеистую сеть открытого доступа (meshnet)</p>

<p> 
Skywire обеспечивает конфиденциальность.</p>

<ul>
<li>Трафик, проходящий через вашу ноду, не может быть отслежен до IP-адреса отправителя</li>
<li>Ноды, передающие трафик, могут видеть только предыдущий и следующий участок маршрута</li>
<li>Третьи стороны, пассивно просматривающие трафик, не могут связать пакеты с конкретным потоком или пользователем</li>
<li>Третьи стороны и передающие ноды не могут прочитать содержимое трафика</li>
</ul>

<p> </p>

<h2 id="маршрутизация-обзор">Маршрутизация: Обзор</h2>

<p> 
Ячеистая сеть Skywire использует протокол хранения и передачи данных по источнику.</p>

<p>Ядром оверлейной сети является группа узлов (нод).
 
* Каждая нода идентифицируется хешем публичного ключа
* Каждая нода получает и отправляет сообщения
* Ноды получают токены за предачу трафика
 </p>

<p>Ноды <code>A</code> и <code>C</code> связываются через ноду <code>B</code> следующим образом:
 
* Нода <code>A</code> связыватся с нодой <code>B</code> и устанавливает Маршрут
* Нода <code>A</code> продлевает Маршрут до <code>C</code>
* Трафик из <code>A</code>, отправленный по Маршруту, прибывает в <code>C</code>
 </p>

<p>При маршруте <code>A -&gt; B -&gt; C -&gt; D</code>:
 
* Ноды знают только предыдущий и последующий участок маршрута.
* <code>C</code> знает, что сообщение прошло через <code>B</code> ушло в <code>D</code>. <code>C</code> не знает про <code>A</code>.
* <code>B</code> не может сделать вывод, что <code>A</code> является началом маршрута.
* <code>C</code> не может сделать вывод, что <code>D</code> является конечной точкой маршрута
* <code>B</code> and <code>C</code> не могут прочитать содержимое сообщения (из-за сквозного шифрования)
* Сторонний наблюдатель, не участвующий в передаче конкретного сообщения, не может получить какую-либо информацию
о содержании сообщения (из-за шифрования канального уровня).
* Несколько сообщений, отправленных по разным маршрутам в один пункт назначения, могут быть объединены, что затрудняет
стороннему наблюдателю возможность анализировать трафик.</p>

<p>В простейшей реализации маршрута используется 128-битный префикс.</p>

<p>Каждая нода считывает префикс и ищет в таблице следующую ноду, которой перенаправляет пакет.</p>

<p>Отправитель сообщения облачает полным контролем над маршрутизацией.
 
* Каждая нода может независимо улучшать протокол маршрутизации в соответствии со своими требованиями
* Отправитель сообщения может оптимизировать сетевой путь с целью уменьшения задержек сети при использовании VоIP или игр
* Отправитель сообщения может оптимизировать сетевой путь с целью увеличения пропускной способности сети при передаче видео
или файлов большого размера
* Отправитель может связать несколько маршрутов к пункту назначения для достижения избыточности, уменьшая задержки
и увеличивая пропускную способность</p>

<p> 
Некоторые приложения могут связывать несколько паралелльных маршрутов на уровне приложений для обеспечения:
 
* конфиденциальности (ноды-шлюзы, сервис типа &ldquo;TOR gateway/anon&rdquo; )
* пропускной способности
* уменьшения задержек
* избыточности</p>

<p>Это ядро оверлейной сети Skycoin. Это очень просто, но крайне эффективно.
Технические подробности и нюансы реализации будут обсуждаться позже.
 
Skywire просто предваряет пакеты идентификатором для маршрутизации.
 
* Маршрутизация получает очень простую табличную форму построения
* Расходы на передачу пакета являются постоянными и не увеличиваются с ростом расстояния</p>

<p>Уточнения:</p>

<ul>
<li>Пункт назначения не идентифицирует отправителя. Идентификация перенесена с уровня маршрутизации на уровень приложения.
Идентификация должна быть подтверждена публичным ключом инфраструктуры.</li>
<li>Атака типа &ldquo;Man-in-middle&rdquo; невозможна. Отправитель может верифицировать получателя через их публичные ключи.</li>
<li>Конфиденциальность существенно улучшена по сравнению с IPv4, где каждый обрабатывающий пакет узел может узнать получателя,
отправителя и содержимое пакета.</li>
<li>Производительность превосходит IPv4/BGP, так как интернет-провайдеры используют неэффективную технологию &ldquo;доставки
горячей картошки&rdquo;</li>
<li>Сквозное шифрование предотвращает атаки подмены пакетов и &ldquo;packet injection&rdquo;. Для подмены трафика нужно иметь приватные
ключи для каждого конца соединительного туннеля.</li>
<li>Быстрое шифрование. У объектов пропусканая способность 10 Гб/с при использовании ПЛИС (FPGA) оборудования,
250 Мб/с для ARM</li>
</ul>

<h2 id="стимулирование-протокол-платежей">Стимулирование: Протокол платежей</h2>

<p> 
<img src="https://i.imgur.com/2zj4CUV.jpg" alt="Skywire miner" />
 
<em><a href="../../../statement/skywire-miner-hardware-for-the-next-internet/">Skywire &ldquo;miner&rdquo;</a></em>
 
Ноды пересылают трафик и получают за это токены. Это эквивалент &ldquo;майнинга&rdquo; в Skycoin, так определяется, сколько пользователей
получат токены за поддержку сети.
 
Платежи за транзит не должны раскрывать ноду-отправителя. Skycoin будет использовать платежи со &ldquo;слепым посредником&rdquo; через
третью сторону пока лучшего протокола не будет разработано.</p>

<p>Каждая нода в маршруте записывает трафик и нода-отправитель пишет трафик. Они регулярно устанавливают размер достаточных платежей.</p>

<p>Отправитель хранит токены на депозите у третьей стороны. Третья сторона создает обезличенный счет. Каждая нода может проверить
репутацию отправителя и платежные возможности через посредника, не производя идентификацию сторон. Для посредника-третьей стороны
каждый отправитель представляется в виде группы несвязанных обезличенных счетов. Каждая транзитная нода видима как группа
несвязанных обезличенных счетов.</p>

<p>Микро-транзакции производятся внутри системы, без записи в блокчейн. Платежи, проводимые без записи в блокчейн, могут быть
выведены на новый, никогда ранее не использованный адрес, если баланс превышает пороговое значение (сейчас 1 Skycoin). Это
уменьшает раздувание размера блокчейна и стимулирует проводить микро-транзакции за пределами блокчейна.</p>

<h2 id="маршрутизация-от-источника-канальное-шифрование">Маршрутизация от источника: Канальное шифрование</h2>

<p>По умолчанию применяется канальное шифрование на участках (&ldquo;плечах&rdquo;) маршрута и сквозное шифрование. Типичное приложение
будет использовать как канальное и сквозное шифрование, так и подходящее шифрование на уровне приложения.</p>

<p>Шифрование между нодами должно быть быстрым. FPGA - реализация оборудования должна поддерживать операционную скорость на линии
в 10 Гб/с. ARM процессоры должны будут поддерживать скорость в 250 Mб/с.</p>

<p>В данный момент наилучший вариант оборудования это ChaCha20 с ECC secp256k1, поддерживающий обмен эфирными ключами.</p>

<p>ChaCha20 использует только простые арифметические операции, работает быстрее, чем AES для встроенных устройств и более устойчив
к атакам типа &ldquo;timing channel&rdquo;, чем AES.</p>

<p>Современные ЦПУ могут производить 6000 secp256k1 ECDH операций в секунду. Сессионные ключи меняются один раз в секунду или
дважды за цикл обработки пакета между нодами. При этом используются отдельные ключи для каждого направления коммуникации.</p>

<p>Предыдущий сессионный ключ должен применяться для формирования ключа по протоколу Диффи-Хеллмана на эллиптических кривых (ECDH).</p>

<p>Сессионный ключ, сформированный посредством публичного криптографического ключа (ECC), используется для зашифрованных
коммуникаций с применением самых быстрых асимметричных шифровальных алгоритмов (AES, ChaCha20). Это основа канального
шифрования между нодами.</p>

<h3 id="пример-протокола-ноды-a-и-b">Пример протокола: Ноды <code>A</code> и <code>B</code></h3>

<ul>
<li>Нода <code>A</code> собирается сгенерировать сессионный ключ для отправки зашифрованных данных ноде <code>B</code></li>
<li>У ноды <code>B</code> есть публичный ключ <code>P</code>, с приватным ключом <code>p</code>. <code>P</code> это точка для ECC sep256k1 кривой. <code>p</code>- это 256 битное
целое число. <code>P</code> является базовой точкой b, возведенной в степень p с операцией сложения.</li>
<li>Нода <code>A</code> генерирует эфемерный публичный ключ <code>Q</code>, с приватным ключом <code>q</code>. (Нода <code>A</code> генерирует случайное 20-байтное
целое число. Это и есть приватный ключ <code>q</code>. Нода <code>A</code> возводит базовую точку в степень <code>q</code>, для генерации публичного ключа <code>Q</code>,
который является точкой кривой).</li>
<li>Нода <code>A</code> отправляет <code>P</code>*<code>q</code> (точка кривой <code>P</code>, представляющая собой публичный ключ <code>B</code>’ в степени <code>q</code>)</li>
<li>Нода <code>A</code> отправляет <code>P</code> ноде <code>B</code></li>
<li>Нода <code>B</code> получает <code>P</code> и вычисляет <code>P*q</code>, нода <code>A</code> может вычислить <code>p*Q</code>, которые равны. Это общий секрет, который хешируется
для генерации сессионного ключа.</li>
<li><code>P = b*q</code>, значит <code>P*q</code> равно <code>(b*p)*q</code>. <code>P*q = (b*p)*q = (b*q)*p = Q*p</code>, поскольку <code>Q=b*q</code>. <code>A</code> знает <code>q,Q</code> и <code>P</code>,
а <code>B</code> знает <code>p,P</code> и <code>Q</code>. значит, <code>A</code> и <code>B</code> оба могут вычислить <code>P*q</code> и <code>Q*p</code> и использовать это как их секрет. Однако,
третья сторона не знает ни приватный ключ <code>q</code> для <code>A</code>, ни приватный ключ <code>p</code> для <code>B</code>, поэтому третья сторона не может
вычислить этот &ldquo;секрет&rdquo; и поэтому не может прочитать информацию, зашифрованную с потомощью секрета.</li>
<li>Нода <code>B</code> подтверждает рецепт обновления сессионных ключей. Нода <code>A</code> начинает передачи под новым сессионным ключом сразу
после получения подтверждения от <code>B</code>.</li>
<li>Нода <code>A</code> отправляет сообщение ноде <code>B</code>, шифруя его с использованием ChaCha20 с помощью сессионного ключа в качестве
асимметричного шифровального ключа.</li>
</ul>

<h3 id="возможные-улучшения">Возможные улучшения:</h3>

<ul>
<li>Частая смена сессионных ключей. Можно менять ECDH ключ каждые несколько секунд или минут.</li>
<li>Хеширование старых сессионных ключей с новым ECDH &ldquo;секретом&rdquo; для генерации нового сессионного ключа.</li>
<li>Добавление временных значений в пакет и хеширование &ldquo;секрета&rdquo; во временное значение для генерации ключа для каждого сообщения.
Подобный ключ повторно не используется. Уменьшает шанс коллизии при известных &ldquo;plaintext&rdquo; атаках.</li>
<li>Удаление известного открытого текста из сообщений.</li>
<li>Дополнение сообщений многократно на 16 или 32 байта.</li>
</ul>

<h2 id="ipv4-шлюз-обход-существующих-интернет-провайдеров">IPv4 шлюз: обход существующих интернет-провайдеров</h2>

<p>Множество людей не имеют возможности выбора среди интернет-провайдеров. Вот краткое описание того, как Skywire может предоставить
такой выбор.</p>

<p>Некоторые приложения могут запускаться непосредственно в адресном пространстве Skywire. Другие программы, подобно Bittorrent,
приложения для совместной работы с файлами и коммуникационные приложения сильно выигрывают от использования инфраструктуры
Skywire и будут модифицированны для работы с ней.</p>

<p>Для устаревших приложений, таких как Netflix, Facebook, Twittter потребуются сетевые шлюзы, соединяющие оверлейную сеть Skywire
с IPv4 и IPv6 сетями.</p>

<p>Пользователь выбирает шлюз Skywire, запущенный на сервере в местном колокейшен-центре. IPv4 трафик пользователя будет
туннелироваться через шлюз (подобно VPN). IP пользователя будет заменяться IP шлюза. Сервер соединен гигабитной линией
с множеством быстрых интернет-магистралей к провайдерам, не ограничивающим Netflix. Пользователь получает множественный
выбор провайдеров через IPv4 шлюз Skywire. Провайдер шлюза получает оплату в Skycoin согласно учета.</p>

<p>Нода Skywire из дома пользователя соединяется со шлюзом всеми доступными способами. Нода Skywire туннелирует IPv4 трафик
от маршрутизатора к шлюзу в колокейшен-центре. IP адрес шлюза становится IP адресом пользователя.</p>

<h3 id="пример-один">Пример один</h3>

<p>У пользователя 10 Mб/с кабельный модем. Он устанавливает Skywire роутер. Роутер подключается к компьютеру, к Skywire Wifi ноде
и кабельному модему. Роутер конфигурируется с Skywire как с IPv4 тоннелем.</p>

<p>Skywire wifi нода соединяется с ближайшей соседней Skywire нодой через wifi, который соединен с 10 Mб/с кабельным модемом.
У соседа также есть 200 Mб/с 5 ГГц wifi с управляющей &ldquo;point-to-point&rdquo; антенной, соединенный с коммерческой нодой Skywire wifi,
размещенной на улице.</p>

<p>Пользователь Skywire роутера выполняет поиск нод с соединением к обычному интернету и устанавливает соединение через:</p>

<ul>
<li>Его кабельный модем</li>
<li>Wifi -&gt; кабельный модем соседа</li>
<li>Wifi -&gt; 5 ГГц &ldquo;point to point&rdquo; -&gt; <sup>100</sup>&frasl;<sub>30</sub> Mб/с коммерческая нода/оптика</li>
</ul>

<p>Пользователь  может объединить широполосный доступ по всем маршрутам, соединяясь с IPv4 тоннелем. В сообществе,
объединившем пользование широкополосным доступом и достигшем определенного уровня надежности, кабельный модем пользователю больше
не будет нужен.</p>

<h3 id="пример-два">Пример два</h3>

<p>Коммерческая линия на улице представляет собой защищенный оптический кабель со скоростью <sup>100</sup>&frasl;<sub>30</sub> Mб/с с фиксированной оплатой
за интернет. Если пропускная способность не используется, она теряется. Коммерческая линия подключается к Skywire роутеру.
У роутера 3 порта. Первый порт - WAN, второй порт используется для локальной сети, к третьему порту подключена Skywire wifi
нода на крыше. Роутер буфферизирует, делит по приоритетам трафик локальной сети и распределяет не использованную емкость
Skywire трафика. Оператор получает токены Skycoin за транзит, покрывая затраты на коммерческую оптику.</p>

<h2 id="архитектура-демона-skywire">Архитектура демона Skywire</h2>

<ul>
<li>Каждая нода Skywire имеет Secpk256k1 публичный ключ</li>
<li>Каждая нода Skywire имеет Skywire адрес для идентификации. Адрес представляет собой хеш публичного ключа ноды. Этот хеш
публичного ключа является эквивалентом IP адреса сети.</li>
<li>Каждая нода Skywire управляет пулом подключений. Это могут быть соединения через TCP, UDP обычного интернета, прямые
подключения через Ethernet и Wifi (операции ячеистой сети). Подключения также могут быть &ldquo;виртуальными&rdquo;, туннелированными
через прямые каналы или каналы обычного интернета, которые будут описаны позднее.</li>
<li>Каждый сеанс подключения имеет &ldquo;каналы&rdquo;. Канал - это 16 битное целое число, аналог &ldquo;порта&rdquo; в TCP.</li>
<li>Все получаемые и отправляемые сообщения имеют 32 битный префикс и 16 битный канал.</li>
<li>Канал 0 зарезервирован для коммуникации между демонами Skywire, содержит мета-данные о запущенных демоном сервисах и
другую необходимую для работы сети информацию.</li>
<li>Демон Skywire может запускать &ldquo;сервисы&rdquo; на канале. Сервис это процесс, который управляет данными, полученных на канале
сообщений и организует переадресацию данных удаленныем узлам и сервисам.</li>
</ul>

<h3 id="пример-сервиса-синхронизация-блокчейна">Пример сервиса: синхронизация блокчейна</h3>

<p><em>Этот пример ссылается на реализацию на Golang, но архитектура демона зависит от конкретного языка.</em></p>

<p>Вы хотите синхронизировать две персональные цепочки блоков пользователей с публичными ключами A и B. Вы инициируете два
экземпляра &ldquo;сервиса синхронизации блокчейна&rdquo;, конфигурируете их с соответствующими публичными ключами и связываете
с демоном Skywire. Эти сервисы запускают ваших локальных демонов, каждого на особом канале.</p>

<h4 id="поиск-узлов">Поиск узлов</h4>

<p>Демоны синхронизации блокчейна хешируют публичные ключи и создают DHT (Distributed Hash Table - распределенную таблицу хешей)
для поиска других узлов, синхронизирующих блокчейн. Как только узлы найдены, они могут быть указаны друг другом как
дополнительные узлы через PEX (Peer Exchange- биржа узлов).</p>

<h4 id="отправка-и-получение-сообщений">Отправка и получение сообщений</h4>

<p>Сервисы создают реестры в виде списка полученных и готовых к отправке сообщений. Сообщения являются Golang-структурами.
Данные сообщений в виде Golang-структур заполняются и затем отправляются. После доставки метод .Handle() вызывает
соответствующее сообщение в виде Golang-структуры.</p>

<h2 id="маршрутизация-нескольких-сетей-и-объединение-каналов">Маршрутизация нескольких сетей и объединение каналов</h2>

<p>Если у вас есть 2 Mб/с кабельный модем, у вашего соседа есть 2 Mб/с кабельный модем и каждый из вас запустит Skywire ноду,
то ваша нода может соединиться с его нодой и объединить пропускную способность двух подключений. Пакеты могут направляться
через любой из двух модемов. Кабельный модем - это &ldquo;бутылочное горло&rdquo;. Если получить 4 Mб/с подключение, трафик будет
проходить через оба модема параллельно.</p>

<p>Приложения подобные Bittorrent смогут объединять широполосный доступ через все доступные подключения, потому что они
по своей природе открывают большое количество соединений при построении маршрутов.</p>

<h2 id="маршрутазация-ячеистой-сети-хранение-и-пересылка">Маршрутазация ячеистой сети: хранение и пересылка</h2>

<p>Существует ряд сложностей по использованию нод на краях ячеистой сети.</p>

<p>Если у вашей сети восемь участков, соединенных через Wifi и 50% пакетов теряется на каждом участке, то только 1 пакет из
256 пройдет весь маршрут. Потеря пакетов обычна для Wifi, но традиционные TCP обрабатывают потерю пакетов как перегруженность
и снижают скорость соединения.</p>

<p>Поэтому на краях сети Skywire вынужден использовать хранение и пересылку по маршрутам. Это накладывает требования к памяти
на Skywire ноды, но существенно улучшает производительность сети.</p>

<p>Для маршрута <code>A-&gt;B-&gt;C</code>
 
* Каждый маршрут имеет буфер.
* Каждая нода продолжает отправлять сообщения, пока они не будут получены и подтверждены.
* Если буфер от <code>B-&gt;C</code> заполнен для маршрута, то <code>A</code> будет это знать и остановит передачу данных до освобождения места в буфере.</p>

<p>Поэтому требуются два подтверждения между нодами на канальном уровне. Одним подтверждением является уведомление о том,
что переданные фрагменты данных были получены. Другим является подтверждение того, что данные из буфера были отправлены
и подтверждены следующим узлом маршрута.</p>

<h2 id="хранение-и-пересылка-использование-пропускной-способности-сети">Хранение и пересылка: Использование пропускной способности сети</h2>

<p>В традиционных IP-сетях при приближении к полному использованию пропускной способности канала эффективность снижается. Сеть,
работающая с пропускной способностью 80%, сталкивается с риском того, что краткосрочный всплеск объема данных приведет к отказу
маршрутизатора из-за переполнения и часть пакетов будет потеряна.</p>

<p>TCP интерпретирует по любой причине потерянные пакеты как переполнение сети и реагирует снижением скорости. Потерянные пакеты
к тому же требуют повторной отправки через TCP и служат причиной задержек, так как приложение ожидает окончания срока доставки,
потом повторной отправки и лишь затем обрабатывет оставшуюся часть пакета.</p>

<p>С операциями хранения и пересылки буфер маршрута заполняется и больше ничего не происходит. Пока буфер полон, нода останавливает
отправку данных до момента получения уведомления об освобождении места в буфере.</p>

<p>Операция хранения и пересылки особенно важна для ячеистых сетей по базе Wifi. Существуют всего три не перекрывающихся канала
в диапазоне 2.4 ГГц. Потери пакетов растут очень быстро и очень скоро перекрывают пропускную способность Wifi сети. Потеря
пакетов Wifi неизбежна и не может служить надежным сигнал переполнения сети или достижения лимита пропускной способности.</p>

<p>Хранение и пересылка позволяет нам запускать Wifi ноды с полным использованием пропускной спосбности и загружать все доступные
каналы без запуска элементов контроля переполнения TCP.</p>

<p>Для запуска сетей на практике потребуется оборудование следующих типов:</p>

<ul>
<li>Программно-управляемый радиоканал</li>
<li>MIMO</li>
<li>beam forming (формирование луча)</li>
<li>направленная антенна</li>
<li>Кооперация использования частот, пропускных способностей каналов во времени и пространстве</li>
<li>801.11af на whitespace (свободных от других нагрузок) частотах</li>
</ul>

<h2 id="хранение-и-пересылка-примеры">Хранение и пересылка: примеры</h2>

<p>Каждая нода для каждого маршрута отслеживает:</p>

<ul>
<li>Размер буфера для получающей трафик ноды</li>
<li>Прогнозируемый размер буфера (по подтвержденным и неподтвержденным сегментам переданных данных)</li>
<li>Подтвержденным размер буфера</li>
<li>Размер, смещение и последовательность каждого переданного сообщения, которое не было подтверждено</li>
<li>Циклический буфер по байтам исходящих датаграмм, которые не получили подтверждения</li>
</ul>

<p>Сегмент данных на уровне канала связи может содержать объединенные сообщения из нескольких маршрутов, адресованных одному узлу.
Это осложняет анализ трафика и повышает производительность за счет предоставления больших датаграмм в сетях, поддерживающих
более высокие MTU (maximum transmission unit - максимальный размер полезного блока данных).</p>

<p>Два подтверждения используются для каждого переданного сообщения. Первое подтверждение в том, что датаграмма получена следующей
нодой маршрута. Это подтверждение для датаграмм, которые могут содержать набор сообщений, каждое из которых передается
по своему маршруту. После получения этого подтверждения ноде больше не требуется хранить датаграмму. Если же датаграмма
не подтверждена, ее необходимо отправить заново.</p>

<p>Второе подтверждение обновляет информацию об оставшемся свободном размере входящего буфера маршрута. Если свободный размер
буфера маршрута достаточен, дополнительное сообщение может быть передано по маршруту.</p>

<p>Другой возможный подход состоит в том, чтобы поддерживать буфер по отправителю, а не по маршруту, с отправкой нескольких копий
сообщений для перегруженных маршрутов. Это уменьшает количество поисковых запросов маршрута, требуемых отправителю, и это то,
с чем, возможно, придется экспериментировать.</p>

<h3 id="пример-обычной-операции">Пример обычной операции</h3>

<p>Маршрут: <code>A-&gt;B-&gt;C</code></p>

<ul>
<li>У B размер буфера для маршрута 1024 KБ</li>
<li>A отправляет 512 KБ -&gt;B</li>
<li>B подтверждает 512 KБ от A</li>
<li>&lt; A получил подтверждение (и первые 512 KБ больше не нужно хранить) &gt;</li>
<li>B пересылает 512 KБ -&gt;C</li>
<li>C подтверждает получение 512 KБ</li>
<li>C подтверждает A, что 512 KБ былы переданы</li>
</ul>

<h3 id="пример-с-переполнением">Пример с переполнением</h3>

<p>Маршрут: <code>A-&gt;B-&gt;C</code></p>

<ul>
<li>У B размер буфера для маршрута 1024 KБ</li>
<li>A отправляет 512 KБ -&gt;B</li>
<li>A отправляет 256 KБ -&gt;B</li>
<li>A отправляет 256 KБ -&gt;B</li>
<li>&lt; A останавливает отправку и ожидает, буфер B уже заполнен&gt;</li>
<li>B подтверждает A получение 512 KБ и 512 KБ</li>
<li>B отправляет 512 KБ и 512 KБ -&gt;C</li>
<li>C подтверждает получение 512 KБ и 512 KБ от B</li>
<li>С подтверждает А, что 512 KБ и 512 KБ были переданы</li>
<li>&lt; A может продолжать передачи &gt;</li>
</ul>

<p> 
Предполагается, что данные получаются в порядке отправления для Wi-Fi и прямого подключения к сети Ethernet</p>

<h3 id="пример-с-потерей-пакета">Пример с потерей пакета</h3>

<p>Маршрут: <code>A-&gt;B-&gt;C</code></p>

<ul>
<li>У B размер буфера для маршрута 1024 KБ</li>
<li>A отправляет 512 KБ -&gt;B</li>
<li>A отправляет 256 KБ -&gt;B</li>
<li>B подтверждает 256 KБ</li>
<li>A делает вывод, что 512 KБ не были получены</li>
<li>A повторно отправляет 512 KБ</li>
<li>B подтверждает 512 KБ</li>
<li>&lt; B может сейчас продолжать отправку пакетов C &gt;</li>
</ul>

<h2 id="хранение-и-пересылка-задержки-и-пропускная-способность">Хранение и пересылка: задержки и пропускная способность</h2>

<p>При хранении и пересылке на передающий узел накладывается требование объема хранения, равное произведению латентности прохождения
в оба конца и скорость передачи на задержку в оба конца. 1 ГБ ОЗУ достаточен для 8000 мс задержки полного прохождения пакета
при скорости передачи 1 Гб/с.</p>

<p>Режим хранения и пересылки устанавливается по умолчанию, но не является обязательным.</p>

<h2 id="хранение-и-пересылка-использование-пропускной-способности-и-качество-обслуживания">Хранение и пересылка: использование пропускной способности и качество обслуживания</h2>

<p>Буферизируется загрузка видео, аудио и файлов. Абсолютная усредненная пропускная способность за отрезок времени имеет значение,
а не латентность. Другой трафик (запросы на веб-сайты, видеоигры и VoIP и пр.) необходимо воспроизводить в реальном времени
и он должен быть доставлен как можно быстрее.</p>

<p>С двумя уровнями качества обслуживания «Real Time» и «Bulk» мы можем сначала передавать VоIP, веб-сайт и «трафик видеоигр»,
уменьшая латентность для этого трафика. Нечувствительный к задержкам трафик («Bulk»- видео, музыка и совместное использование файлов)
будет проходить по каналу только после того, как буфер трафика «Real Time» опустеет.</p>

<p>Мы можем использовать каналы почти на 100% мощности, а также снизить латентность трафика «Real Time». Поэтому мы
предлагаем поддерживать два уровня обслуживания для маршрутов.</p>

<h2 id="маршрутизация-от-источника-множественные-маршруты-для-мобильного-подключения">Маршрутизация от источника: множественные маршруты для мобильного подключения</h2>

<p>Если соединения между узлами являются стабильными, с маленькой задержкой и имеют высокую пропускную способность, то
для большинства приложений достаточно одного маршрута. Некоторые приложения, такие как Bittorrent, открывают большое
количество подключений и изначально могут использовать нужную пропускную способность для всех доступных маршрутов.</p>

<p>Если связь между узлами медленная, ненадежная или соединения меняются, надежность и производительность требуют,
чтобы трафик был мультиплексирован по нескольким избыточным маршрутам.</p>

<p>Если нода Skywire, работающая на сотовом телефоне, находится в автомобиле, движущемся по улице, доступные сети будут меняться.
Одни сетевые узлы будут становиться доступны, а другие из доступа пропадут. Нода должна иметь непрерывную связь на уровне приложения,
даже если физические соединения создаются и разрываются.</p>

<p>Одним из подходов является выбор набора надежных узлов на сетевой магистрали в качестве точек завершения маршрута,
а затем проксирование трафика через эти узлы по множеству краткосрочных маршрутов.</p>

<h2 id="маршрутизация-от-источника-надежность-избыточных-маршрутов">Маршрутизация от источника: надежность избыточных маршрутов</h2>

<p>Если каналы ненадежны или имеют большую переменную задержку, желательно передавать данные приложений несколькими путями.
Тогда они могут быть восстановлены, если получены данные хотя бы по одному из маршрутов. Для этого могут быть использованы
фонтанные коды и другие методы кодирования.</p>

<h2 id="маршрутизация-от-источника-ноды-стражи">Маршрутизация от источника: ноды-стражи</h2>

<p>Для обеспечения конфиденциальности, если пользователь хочет еще более ослабить связь между своим адресом ноды Skywire
(хешем открытого ключа) и IP-адресом, он может определить фиксированный набор узлов, которые устанавливаются как
рекомендуемые транзитные точки для трафика, предназначенного для определенного адреса, или действуют как обязательные узлы
при построении маршрутов с данного адреса.</p>

<h2 id="маршрутизация-от-источника-ограничения-для-bgp">Маршрутизация от источника: ограничения для BGP</h2>

<p>Border Gateway Protocol (BGP), протокол граничного шлюза, доминирующий сейчас протокол маршрутизации, обрабатывает
проблему маршрутизации, не сохраняя никакого состояния пакетов. Вместо этого BGP позволяет каждой сети создавать
серии специальных правил для каждого из своих маршрутизаторов, которые смотрят на отправителя и получателя пакета и определяют,
какую сеть задействовать для пересылки пакет. Маршрутизаторы сообщают друг другу информацию о подключениях, а для маршрутизации
в сетевом домене используется другой алгоритм маршрутизации.</p>

<p>BGP предназначен для взаимодействия нескольких независимых автономных сетей. BGP имеет допущение о гомогенности, предполагается,
что маршрутизация в автономном домене централизованно управляется и высоконадежна, причем внутри домена она однородна.
Ячеистые сети и интернет-провайдеры сообщества будут иметь специальную связь с гетерогенным подключением и маршрутизацией устройств.</p>

<p>Связность в ячеистых сетях, специальных конфигурациях и взаимосвязанных сетях с избыточными маршрутами через несколько сетей
полностью нарушает иерархические допущения BGP.</p>

<p>Однако, альтернативы BGP нет. BGP - лучшее решение в рамках своих конструктивных ограничений.</p>

<p>В BGP есть несколько вопросов, которые должен решить протокол следующего поколения:</p>

<ul>
<li>BGP не настраивается самостоятельно. Для настройки и использования сетей BGP требуются обширные технические знания</li>
<li>Системы BGP часто требуют ручной настройки для маршрутизации вокруг поврежденных участков и не являются устойчивыми к
плохим конфигурациям</li>
<li>BGP требует ручного создания правил отбора специальных маршрутов и имеет повышенную сложность для поддержки соединений
объектов к нескольким разным сетям</li>
<li>Сети BGP требуют высокоцентрализованного планирования</li>
<li>NSA использует недостатки в BGP для маршрутизации целевого трафика на точки перехвата</li>
<li>Предположения BGP становятся все более натянутыми, особенно для специальных, ячеистых и мобильных сетей</li>
<li>Иерархические, однопотоковые предположения BGP делают чрезвычайно сложным реализацию многопоточности и других требований к
сетям следующего поколения</li>
<li>BGP испытывает серьезные проблемы, когда сетевые каналы ненадежны, например, при мерцании маршрута</li>
<li>Размер таблицы маршрутизации BGP растет экспоненциально по мере присоединения взаимосвязанных подсетей</li>
<li>Применение множественных маршрутов вызывает резкий рост размера таблицы маршрутизации BGP</li>
<li>BGP испытывает трудности с балансировкой нагрузки и маршрутизацией через несколько сетей. BGP ограничивает возможности
использовать в реальных сетях параллельные подключения между локациями</li>
<li>BGP создает стимул для интернет-провайдеров как можно быстрее сбрасывать сетевой трафик в другие сети («маршрутизация
горячей картошки»), снижая производительность и увеличивая время ожидания</li>
</ul>

<p>Преемник BGP должен:</p>

<ul>
<li>Быть не-иерархическим</li>
<li>Быть самонастраивающимся (zero-conf)</li>
<li>Хорошо работать с плотным специальными, избыточными соединениеми между сетями</li>
</ul>

<h2 id="виртуальные-маршруты-масштабирование-топологии-сети-skywire">Виртуальные маршруты: масштабирование топологии сети Skywire</h2>

<p>Для реализации маршрутизации Skywire требуется, чтобы нода поддерживала информацию для каждого маршрута, который проходит
через нее. Отдельные ноды не могут обрабатывать сотни тысяч отдельных маршрутов и поэтому масштабируемость достигается
с помощью другого механизма.</p>

<p>Skywire экспериментирует с не-иерархической самоорганизующейся маршрутизацией, которая изначально поддерживает
многопользовательские и не-иерархические топологии сети с эффективным масштабированием.</p>

<p>Skywire минимизирует размер сети, поскольку сеть масштабируется с помощью виртуальных маршрутов. Виртуальные маршруты
позволяют подключать тысячи подключений по высокоскоростному магистральному соединению с накладными расходами одного маршрута.</p>

<p>«Виртуальный маршрут» создает туннель по существующему маршруту:</p>

<p><code>A -&gt; B -&gt; C -&gt; D</code></p>

<p>Виртуальный маршрут отображается как A-&gt; D. B и C могут быть высокоскоростными соединениями на большие расстояния.
B и C несут только накладные расходы одного маршрута, а A и D - накладные расходы на поддержание маршрутов в туннеле A-&gt; D.</p>

<p>Виртуальный маршрут может содержать трафик от сотен связанных маршрутов от A до D, тогда как B и C имеют только
накладные расходы одного маршрута. Виртуальный маршрут может дополнительно включать в себя множество избыточных сетевых путей
между отправителем и получателем для улучшения производительности, пропускной способности и избыточности.</p>

<p>Виртуальные маршруты позволяют объединить пропускную способность иерархической сети с узлами с постоянными
накладными расходами и подключениями на каждом уровне.</p>

<p>Узлы на границе сети подключаются в узлы агрегации. Узлы агрегации краев соединены транзитным каналом с высокой
пропускной способностью и связаны в узлы-шлюзы, которые взаимодействуют между сетями. Узлы-шлюзы подключают высокоскоростные
каналы и каналы больших расстояний.</p>

<p>Виртуальные маршруты являются представлением существующих междоменных маршрутных подключений, которые изначально поддерживают:</p>

<ul>
<li>не-иерархическую маршрутизацию (дата центры)</li>
<li>Multiple-homing (подключение к нескольким сетям)</li>
<li>Плотная сетевая взаимосвязь между доменами на разных уровнях иерархии</li>
<li>Многоканальная маршрутизация внутри и между сетевыми доменами</li>
</ul>

<p>Виртуальные маршруты подчиняются правилу треугольника. Если стоимость маршрута A-&gt; B, равна C (A-&gt; B), то</p>

<p><code>C(A-&gt;B-&gt;C) &gt;= C(A-&gt;B) + C(B-&gt;C)</code></p>

<p>Предпочтение отдается маршрутам с меньшей задержкой, низкой стоимостью и коротким &ldquo;плечом&rdquo;, что создает экономические стимулы
для создания эффективной топологии сети. Сеть не-иерархическая и самоорганизующаяся. Созданные виртуальные маршруты
представляют собой объединения маршрутов, которые, естественно, передают поток трафика.</p>

<p>В протоколе BGP сети пытаются как можно быстрее избавиться от трафика (&ldquo;маршрутизация горячей картошки&rdquo;). В Skywire сети
конкурируют за транзит (для получения стимулов в виде токенов). Клиенты Skywire будут предпочитать маршруты дешевые,
с короткими &ldquo;плечами&rdquo; и малыми задержками. Сети с большой пропускной способностью между источником и пунктом назначения
имеют меньшую задержку и меньшее число переходов и, следовательно, получают предпочтение.</p>

<p>Для сохранения эффективности пропускная способность и число &ldquo;клиентов&rdquo; (количество маршрутов, которые связывает каждый
виртуальный маршрут) на каждом уровне сетевой иерархии должны быть постоянными, чтобы обеспечить ровный рост размера сети
и логарифмической таблицы маршрутизации узлов.</p>

<h2 id="маршрутизация-от-источника-виртуальные-маршруты-топология-sonet">Маршрутизация от источника: виртуальные маршруты, топология SONET</h2>

<p>Виртуальный маршрут с несколькими входами и несколькими выводами может быть физически реализован в виде кольца SONET с
нодами Skywire в каждом городе, организованными по топологии SONET. Узлы Skywire выступают в роли шлюзового маршрутизатора
между сетью Skywire и топологией SONET.</p>

<p>Ноды могут ставить в очередь большие датаграммы, объединяя для эффективности несколько сообщений от одного источника
до одного и того же адресата.</p>

<p>Сообщение входит в ноду Skywire кольца SONET в колокейшен-центре в одном городе. Пункт назначения или маршрут сообщения
считывается, и сообщение кодируется для переноса по сегменту SONET. Сообщение приходит в ноду назначения Skywire
в сегменте SONET и продолжается по его пути.</p>

<p>Таким образом, виртуальный маршрут с несколькими входами и выходами является списком нод Skywire со стоимостью транзита,
описывающей кольцо SONET или полностью связанную топологию, где любой узел в списке имеет транзит в любой другой узел в списке.</p>

<h2 id="маршрутизация-от-источника-асимметричное-подключение">Маршрутизация от источника: асимметричное подключение</h2>

<p>Системы следующего поколения WiFi будут иметь антенны 4x4 и 8x8 в схеме MIMO с фазированной решеткой. Такие системы
способны проектировать сильно сфокусированные направленные лучи. Эти системы значительно увеличивают мощность
и силу сигнала в приемнике, но не улучшают симметрично возможности антенны по приему обратных сигналов.</p>

<p>Аналогично, высокомодульный усиленный сигнал WiFi через направленную антенну может быть принят на участке, находящемся
за пятнадцать миль, но прием сигнала с сайта не может быть аналогичным образом усилен так же легко, как можно повысить
мощность передачи.</p>

<p>Мы предлагаем асимметричные маршруты для ситуации, когда сообщения могут быть получены нодой, но ноды не могут напрямую
обмениваться данными. В асимметричных маршрутах сообщения подтверждения передаются по сети по маршруту, что позволяет
полностью использовать асимметричные подключения по односторонним каналам связи.</p>

<p>Ситуации, когда это станет все более актуальным:</p>

<ul>
<li>Схемы сельских SONET с усиленным WiFi по направленным антеннам</li>
<li>Городская связь между высоконаправленными и не направленными антеннами, вещающими на одинаковых уровнях мощности</li>
<li>преодоление бетонных преград в 802.11af системах</li>
<li>LiFi с распространением за пределами прямой видимости может передавать данные со скоростью более 200 Мб/с,
но с высокой асимметричностью</li>
<li>Системы Li-Fi типа RONJA имеют теоретические пределы пропускной способности при прямой видимости 10 Гб/с,
и при асимметричной связи есть преимущество по стоимости/настройке</li>
</ul>

<p>Использование асимметричных соединений и маршрутов, обеспечивающих только одностороннюю прямую передачу данных
между узлами, имеет несколько преимуществ, особенно для развития сельских районов и снижения стоимости применения
технологий высокой пропускной способности для сетей следующего поколения.</p>

<h2 id="маршрутизация-от-источника-открытие-маршрутов">Маршрутизация от источника: открытие маршрутов</h2>

<p>Шлюз IPv4 и ячеистые сети интернет-провайдеров сообщества требуют для постоения мершрута лишь однократного соединения
к обычному интернету. Наилучшие, самые надежные, самые высокопропускные каналы имеют очень небольшую загрузку.
Поэтому мы рассматриваем маршрутизацию применительно для этого случая.
Позже рассмотрим общую маршрутизацию.</p>

    </article>

    
    
</section>

<footer style="background-color:darkgray;">
    <a href="">SkyCoin Logo</a>
    <p>En, Cn, Ko, Jp</p>
    <nav>
        <div>
            <ul>
                <li>SkyCoin</li>
                <li>
                    <a href="">Team</a>
                </li>
                <li>
                    <a href="">Blog</a>
                </li>
                <li>
                    <a href="https://explorer.skycoin.net/app/blocks/1">Blockchain Explorer</a>
                </li>
            </ul>
        </div>
        <div>
            <ul>
                <li>Technology</li>
                <li>
                    <a href="">SkyWire</a>
                </li>
                <li>
                    <a href="../../../skycoin">SkyCoin</a>
                </li>
                <li>
                    <a href="">SkyMiner</a>
                </li>
            </ul>
        </div>
        <div>
            <ul>
                <li><a href=""></a>Community</li>
                
                    <li><a class="footer__link" href="https://www.skycoin.net/">skycoin.net</a></li>
                
                    <li><a class="footer__link" href="https://github.com/skycoin">Github</a></li>
                
                    <li><a class="footer__link" href="https://twitter.com/skycoinproject">Twitter</a></li>
                
                    <li><a class="footer__link" href="https://reddit.com/r/SkycoinProject">Reddit</a></li>
                
                    <li><a class="footer__link" href="https://t.me/Skycoin">Telegram</a></li>
                
                    <li><a class="footer__link" href="https://explorer.skycoin.net/">Blockchain Explorer</a></li>
                
            </ul>
        </div>
        <div>
            <ul>
                <li>Contact</li>
                <li>
                    <a>Email Us</a>
                </li>
                <li>
                    <a href="https://www.skycoin.net/mailing-list/" target="_blank">Mailing List</a>
                </li>
            </ul>
        </div>
    </nav>
</footer>
    

    <script src="../../../app.js"></script>


  <script>
    var dropdown = document.querySelector('.js-dropdown'),
      list = dropdown.querySelector('.js-dropdown-list'),
      current = dropdown.querySelector('.js-dropdown-current');

    current.addEventListener('click', function(e) {
      list.classList.toggle('header-dropdown__list_show');

      document.addEventListener('click', function(e) {
        if(!dropdown.contains(e.target)) {
          list.classList.remove('header-dropdown__list_show');
        }
      });
    }, false)
  </script>

  <script src="../../../app.js"></script>

  
    <script src="//platform.twitter.com/oct.js" type="text/javascript"></script>
    <script type="text/javascript">
    if (window.twttr) {
      twttr.conversion.trackPid('ny03t', { tw_sale_amount: 0, tw_order_quantity: 0 });
    } </script>
    <noscript>
    <img height="1" width="1" style="display:none;" alt="" src="https://analytics.twitter.com/i/adsct?txn_id=ny03t&p_id=Twitter&tw_sale_amount=0&tw_order_quantity=0" />
    <img height="1" width="1" style="display:none;" alt="" src="//t.co/i/adsct?txn_id=ny03t&p_id=Twitter&tw_sale_amount=0&tw_order_quantity=0" />
    </noscript>
  

</body>
</html>
